{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"@babel/runtime/helpers/toConsumableArray\");\nvar _defineProperty = require(\"@babel/runtime/helpers/defineProperty\");\nvar _slicedToArray = require(\"@babel/runtime/helpers/slicedToArray\");\nvar _objectWithoutProperties = require(\"@babel/runtime/helpers/objectWithoutProperties\");\nvar _excluded = [\"preserveGroups\", \"preserveDynamicRoutes\"];\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.appendBaseUrl = exports.deepEqual = exports.getPathDataFromState = void 0;\nvar core_1 = require(\"@react-navigation/core\");\nvar matchers_1 = require(\"../matchers\");\nvar DEFAULT_SCREENS = {};\nvar _getActiveRoute = function getActiveRoute(state) {\n  var route = typeof state.index === 'number' ? state.routes[state.index] : state.routes[state.routes.length - 1];\n  if (route.state) {\n    return _getActiveRoute(route.state);\n  }\n  if (route && isInvalidParams(route.params)) {\n    return _getActiveRoute(createFakeState(route.params));\n  }\n  return route;\n};\nfunction createFakeState(params) {\n  return {\n    stale: false,\n    type: 'UNKNOWN',\n    key: 'UNKNOWN',\n    index: 0,\n    routeNames: [],\n    routes: [{\n      key: 'UNKNOWN',\n      name: params.screen,\n      params: params.params,\n      path: params.path\n    }]\n  };\n}\nfunction segmentMatchesConvention(segment) {\n  return segment === 'index' || (0, matchers_1.matchDynamicName)(segment) != null || (0, matchers_1.matchGroupName)(segment) != null || (0, matchers_1.matchDeepDynamicRouteName)(segment) != null;\n}\nfunction encodeURIComponentPreservingBrackets(str) {\n  return encodeURIComponent(str).replace(/%5B/g, '[').replace(/%5D/g, ']');\n}\nfunction getPathFromState(state, _options) {\n  return getPathDataFromState(state, _options).path;\n}\nexports.default = getPathFromState;\nfunction getPathDataFromState(state) {\n  var _options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    screens: DEFAULT_SCREENS\n  };\n  if (state == null) {\n    throw Error(\"Got 'undefined' for the navigation state. You must pass a valid state object.\");\n  }\n  var preserveGroups = _options.preserveGroups,\n    preserveDynamicRoutes = _options.preserveDynamicRoutes,\n    options = _objectWithoutProperties(_options, _excluded);\n  (0, core_1.validatePathConfig)(options);\n  if (Object.is(options.screens, DEFAULT_SCREENS)) {\n    throw Error(\"You must pass a 'screens' object to 'getPathFromState' to generate a path.\");\n  }\n  return getPathFromResolvedState(JSON.parse(JSON.stringify(state)), createNormalizedConfigs(options.screens), {\n    preserveGroups: preserveGroups,\n    preserveDynamicRoutes: preserveDynamicRoutes\n  });\n}\nexports.getPathDataFromState = getPathDataFromState;\nfunction processParamsWithUserSettings(configItem, params) {\n  var stringify = configItem == null ? void 0 : configItem.stringify;\n  return Object.fromEntries(Object.entries(params).map(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n      key = _ref2[0],\n      value = _ref2[1];\n    return [key, stringify != null && stringify[key] ? stringify[key](value) : Array.isArray(value) ? value : String(value)];\n  }));\n}\nfunction deepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n  if (Array.isArray(a) && Array.isArray(b)) {\n    if (a.length !== b.length) {\n      return false;\n    }\n    for (var i = 0; i < a.length; i++) {\n      if (!deepEqual(a[i], b[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  if (typeof a === 'object' && typeof b === 'object') {\n    var keysA = Object.keys(a);\n    var keysB = Object.keys(b);\n    if (keysA.length !== keysB.length) {\n      return false;\n    }\n    for (var key of keysA) {\n      if (!deepEqual(a[key], b[key])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return false;\n}\nexports.deepEqual = deepEqual;\nfunction walkConfigItems(route, focusedRoute, configs, _ref3) {\n  var preserveDynamicRoutes = _ref3.preserveDynamicRoutes;\n  if (!route.state && isInvalidParams(route.params)) {\n    route.state = createFakeState(route.params);\n  }\n  var pattern = null;\n  var focusedParams;\n  var collectedParams = {};\n  while (route.name in configs) {\n    var _route$state$index;\n    var configItem = configs[route.name];\n    var inputPattern = configItem.pattern;\n    if (inputPattern == null) {\n      throw new Error('Unexpected: No pattern found for route ' + route.name);\n    }\n    pattern = inputPattern;\n    if (route.params) {\n      var params = processParamsWithUserSettings(configItem, route.params);\n      if (pattern !== undefined && pattern !== null) {\n        Object.assign(collectedParams, params);\n      }\n      if (deepEqual(focusedRoute, route)) {\n        if (preserveDynamicRoutes) {\n          focusedParams = params;\n        } else {\n          focusedParams = getParamsWithConventionsCollapsed({\n            params: params,\n            pattern: pattern,\n            routeName: route.name\n          });\n        }\n      }\n    }\n    if (!route.state && isInvalidParams(route.params)) {\n      route.state = createFakeState(route.params);\n    }\n    if (!configItem.screens || route.state === undefined) {\n      var _configItem$screens$c;\n      if (configItem.initialRouteName && configItem.screens && configItem.initialRouteName in configItem.screens && (_configItem$screens$c = configItem.screens[configItem.initialRouteName]) != null && _configItem$screens$c.pattern) {\n        var initialRouteConfig = configItem.screens[configItem.initialRouteName];\n        pattern = initialRouteConfig.pattern;\n        if (focusedParams) {\n          if (!preserveDynamicRoutes) {\n            focusedParams = getParamsWithConventionsCollapsed({\n              params: focusedParams,\n              pattern: pattern,\n              routeName: route.name\n            });\n          }\n        }\n      }\n      break;\n    }\n    var index = (_route$state$index = route.state.index) != null ? _route$state$index : route.state.routes.length - 1;\n    var nextRoute = route.state.routes[index];\n    var nestedScreens = configItem.screens;\n    if (nestedScreens && nextRoute.name in nestedScreens) {\n      route = nextRoute;\n      configs = nestedScreens;\n    } else {\n      break;\n    }\n  }\n  if (pattern == null) {\n    throw new Error(`No pattern found for route \"${route.name}\". Options are: ${Object.keys(configs).join(', ')}.`);\n  }\n  if (pattern && !focusedParams && focusedRoute.params) {\n    if (preserveDynamicRoutes) {\n      focusedParams = focusedRoute.params;\n    } else {\n      focusedParams = getParamsWithConventionsCollapsed({\n        params: focusedRoute.params,\n        pattern: pattern,\n        routeName: route.name\n      });\n    }\n    Object.assign(focusedParams, collectedParams);\n  }\n  return {\n    pattern: pattern,\n    nextRoute: route,\n    focusedParams: focusedParams,\n    params: collectedParams\n  };\n}\nfunction getPathFromResolvedState(state, configs, _ref4) {\n  var preserveGroups = _ref4.preserveGroups,\n    preserveDynamicRoutes = _ref4.preserveDynamicRoutes;\n  var path = '';\n  var current = state;\n  var allParams = {};\n  while (current) {\n    var _current$index, _configs$nextRoute$na, _nextRoute$state$rout, _nextRoute$state$rout2, _nextRoute$state$inde, _nextRoute$state;\n    path += '/';\n    var route = current.routes[(_current$index = current.index) != null ? _current$index : 0];\n    if (!route.state && isInvalidParams(route.params)) {\n      route.state = createFakeState(route.params);\n    }\n    var _walkConfigItems = walkConfigItems(route, _getActiveRoute(current), _objectSpread({}, configs), {\n        preserveDynamicRoutes: preserveDynamicRoutes\n      }),\n      pattern = _walkConfigItems.pattern,\n      params = _walkConfigItems.params,\n      nextRoute = _walkConfigItems.nextRoute,\n      focusedParams = _walkConfigItems.focusedParams;\n    Object.assign(allParams, params);\n    path += getPathWithConventionsCollapsed({\n      pattern: pattern,\n      routePath: nextRoute.path,\n      params: allParams,\n      initialRouteName: (_configs$nextRoute$na = configs[nextRoute.name]) == null ? void 0 : _configs$nextRoute$na.initialRouteName,\n      preserveGroups: preserveGroups,\n      preserveDynamicRoutes: preserveDynamicRoutes\n    });\n    if (nextRoute.state && configs[(_nextRoute$state$rout = nextRoute.state.routes) == null ? void 0 : (_nextRoute$state$rout2 = _nextRoute$state$rout[(_nextRoute$state$inde = (_nextRoute$state = nextRoute.state) == null ? void 0 : _nextRoute$state.index) != null ? _nextRoute$state$inde : 0]) == null ? void 0 : _nextRoute$state$rout2.name]) {\n      current = nextRoute.state;\n    } else {\n      if (focusedParams) {\n        for (var param in focusedParams) {\n          if (focusedParams[param] === 'undefined') {\n            delete focusedParams[param];\n          }\n        }\n        var query = new URLSearchParams(focusedParams).toString();\n        if (query) {\n          path += `?${query}`;\n        }\n      }\n      break;\n    }\n  }\n  return {\n    path: appendBaseUrl(basicSanitizePath(path)),\n    params: decodeParams(allParams)\n  };\n}\nfunction decodeParams(params) {\n  var parsed = {};\n  for (var _ref5 of Object.entries(params)) {\n    var _ref6 = _slicedToArray(_ref5, 2);\n    var key = _ref6[0];\n    var value = _ref6[1];\n    try {\n      if (Array.isArray(value)) {\n        parsed[key] = value.map(function (v) {\n          return decodeURIComponent(v);\n        });\n      } else {\n        parsed[key] = decodeURIComponent(value);\n      }\n    } catch (_unused) {\n      parsed[key] = value;\n    }\n  }\n  return parsed;\n}\nfunction getPathWithConventionsCollapsed(_ref7) {\n  var pattern = _ref7.pattern,\n    routePath = _ref7.routePath,\n    params = _ref7.params,\n    preserveGroups = _ref7.preserveGroups,\n    preserveDynamicRoutes = _ref7.preserveDynamicRoutes,\n    initialRouteName = _ref7.initialRouteName;\n  var segments = pattern.split('/');\n  return segments.map(function (p, i) {\n    var name = getParamName(p);\n    if (p.startsWith('*')) {\n      if (preserveDynamicRoutes) {\n        if (name === 'not-found') {\n          return '+not-found';\n        }\n        return `[...${name}]`;\n      }\n      if (params[name]) {\n        if (Array.isArray(params[name])) {\n          return params[name].join('/');\n        }\n        return params[name];\n      }\n      if (i === 0) {\n        return routePath;\n      }\n      return routePath == null ? void 0 : routePath.split('/').slice(i + 1).join('/');\n    }\n    if (p.startsWith(':')) {\n      if (preserveDynamicRoutes) {\n        return `[${name}]`;\n      }\n      return params[name];\n    }\n    if (!preserveGroups && (0, matchers_1.matchGroupName)(p) != null) {\n      if (segments.length - 1 === i) {\n        if (initialRouteName) {\n          if (segmentMatchesConvention(initialRouteName)) {\n            return '';\n          }\n          return encodeURIComponentPreservingBrackets(initialRouteName);\n        }\n      }\n      return '';\n    }\n    return encodeURIComponentPreservingBrackets(p);\n  }).map(function (v) {\n    return v != null ? v : '';\n  }).join('/');\n}\nfunction getParamsWithConventionsCollapsed(_ref8) {\n  var pattern = _ref8.pattern,\n    routeName = _ref8.routeName,\n    params = _ref8.params;\n  var processedParams = _objectSpread({}, params);\n  var segments = pattern.split('/');\n  segments.filter(function (segment) {\n    return segment.startsWith(':');\n  }).forEach(function (segment) {\n    var name = getParamName(segment);\n    delete processedParams[name];\n  });\n  if (segments.some(function (segment) {\n    return segment.startsWith('*');\n  })) {\n    var _ref9;\n    var name = (0, matchers_1.testNotFound)(routeName) ? 'not-found' : (_ref9 = (0, matchers_1.matchDeepDynamicRouteName)(routeName)) != null ? _ref9 : routeName;\n    delete processedParams[name];\n  }\n  return processedParams;\n}\nfunction basicSanitizePath(path) {\n  var simplifiedPath = path.replace(/\\/+/g, '/');\n  if (simplifiedPath.length <= 1) {\n    return simplifiedPath;\n  }\n  return simplifiedPath.replace(/\\/$/, '');\n}\nfunction isInvalidParams(params) {\n  if (!params) {\n    return false;\n  }\n  if ('params' in params && typeof params.params === 'object' && !!params.params) {\n    return true;\n  }\n  return 'initial' in params && typeof params.initial === 'boolean' && 'screen' in params;\n}\nvar getParamName = function getParamName(pattern) {\n  return pattern.replace(/^[:*]/, '').replace(/\\?$/, '');\n};\nvar joinPaths = function joinPaths() {\n  var _ref0;\n  for (var _len = arguments.length, paths = new Array(_len), _key = 0; _key < _len; _key++) {\n    paths[_key] = arguments[_key];\n  }\n  return (_ref0 = []).concat.apply(_ref0, _toConsumableArray(paths.map(function (p) {\n    return p.split('/');\n  }))).filter(Boolean).join('/');\n};\nvar createConfigItem = function createConfigItem(config, parentPattern) {\n  if (typeof config === 'string') {\n    var _pattern = parentPattern ? joinPaths(parentPattern, config) : config;\n    return {\n      pattern: _pattern\n    };\n  }\n  if (config.exact && config.path === undefined) {\n    throw new Error(\"A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. `path: ''`.\");\n  }\n  var pattern = config.exact !== true ? joinPaths(parentPattern || '', config.path || '') : config.path || '';\n  var screens = config.screens ? createNormalizedConfigs(config.screens, pattern) : undefined;\n  return {\n    pattern: pattern == null ? void 0 : pattern.split('/').filter(Boolean).join('/'),\n    stringify: config.stringify,\n    screens: screens,\n    initialRouteName: config.initialRouteName\n  };\n};\nvar createNormalizedConfigs = function createNormalizedConfigs(options, pattern) {\n  return Object.fromEntries(Object.entries(options).map(function (_ref1) {\n    var _ref10 = _slicedToArray(_ref1, 2),\n      name = _ref10[0],\n      c = _ref10[1];\n    return [name, createConfigItem(c, pattern)];\n  }));\n};\nfunction appendBaseUrl(path) {\n  var baseUrl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n  if (process.env.NODE_ENV !== 'development') {\n    if (baseUrl) {\n      return `/${baseUrl.replace(/^\\/+/, '').replace(/\\/$/, '')}${path}`;\n    }\n  }\n  return path;\n}\nexports.appendBaseUrl = appendBaseUrl;","map":{"version":3,"names":["core_1","require","matchers_1","DEFAULT_SCREENS","getActiveRoute","state","route","index","routes","length","isInvalidParams","params","createFakeState","stale","type","key","routeNames","name","screen","path","segmentMatchesConvention","segment","matchDynamicName","matchGroupName","matchDeepDynamicRouteName","encodeURIComponentPreservingBrackets","str","encodeURIComponent","replace","getPathFromState","_options","getPathDataFromState","exports","default","arguments","undefined","screens","Error","preserveGroups","preserveDynamicRoutes","options","_objectWithoutProperties","_excluded","validatePathConfig","Object","is","getPathFromResolvedState","JSON","parse","stringify","createNormalizedConfigs","processParamsWithUserSettings","configItem","fromEntries","entries","map","_ref","_ref2","_slicedToArray","value","Array","isArray","String","deepEqual","a","b","i","keysA","keys","keysB","walkConfigItems","focusedRoute","configs","_ref3","pattern","focusedParams","collectedParams","_route$state$index","inputPattern","assign","getParamsWithConventionsCollapsed","routeName","_configItem$screens$c","initialRouteName","initialRouteConfig","nextRoute","nestedScreens","join","_ref4","current","allParams","_current$index","_configs$nextRoute$na","_nextRoute$state$rout","_nextRoute$state$rout2","_nextRoute$state$inde","_nextRoute$state","_walkConfigItems","_objectSpread","getPathWithConventionsCollapsed","routePath","param","query","URLSearchParams","toString","appendBaseUrl","basicSanitizePath","decodeParams","parsed","_ref5","_ref6","v","decodeURIComponent","_unused","_ref7","segments","split","p","getParamName","startsWith","slice","_ref8","processedParams","filter","forEach","some","_ref9","testNotFound","simplifiedPath","initial","joinPaths","_ref0","_len","paths","_key","concat","apply","_toConsumableArray","Boolean","createConfigItem","config","parentPattern","exact","_ref1","_ref10","c","baseUrl","process","env","NODE_ENV"],"sources":["/Users/jonathanbruce/Coding/trackr/node_modules/expo-router/src/fork/getPathFromState.ts"],"sourcesContent":["import { PathConfig, PathConfigMap, validatePathConfig } from '@react-navigation/core';\nimport type { NavigationState, PartialState, Route } from '@react-navigation/routers';\n\nimport {\n  matchDeepDynamicRouteName,\n  matchDynamicName,\n  matchGroupName,\n  testNotFound,\n} from '../matchers';\n\ntype Options<ParamList extends object> = {\n  initialRouteName?: string;\n  screens: PathConfigMap<ParamList>;\n};\n\nexport type State = NavigationState | Omit<PartialState<NavigationState>, 'stale'>;\n\ntype StringifyConfig = Record<string, (value: any) => string>;\n\ntype ConfigItem = {\n  pattern?: string;\n  stringify?: StringifyConfig;\n  screens?: Record<string, ConfigItem>;\n  // Used as fallback for groups\n  initialRouteName?: string;\n};\n\ntype CustomRoute = Route<string> & {\n  state?: State;\n};\n\nconst DEFAULT_SCREENS: PathConfigMap<object> = {};\n\nconst getActiveRoute = (state: State): { name: string; params?: object } => {\n  const route =\n    typeof state.index === 'number'\n      ? state.routes[state.index]\n      : state.routes[state.routes.length - 1];\n\n  if (route.state) {\n    return getActiveRoute(route.state);\n  }\n\n  if (route && isInvalidParams(route.params)) {\n    return getActiveRoute(createFakeState(route.params));\n  }\n\n  return route;\n};\n\nfunction createFakeState(params: StateAsParams) {\n  return {\n    stale: false,\n    type: 'UNKNOWN',\n    key: 'UNKNOWN',\n    index: 0,\n    routeNames: [],\n    routes: [\n      {\n        key: 'UNKNOWN',\n        name: params.screen,\n        params: params.params,\n        path: params.path,\n      },\n    ],\n  };\n}\n\nfunction segmentMatchesConvention(segment: string): boolean {\n  return (\n    segment === 'index' ||\n    matchDynamicName(segment) != null ||\n    matchGroupName(segment) != null ||\n    matchDeepDynamicRouteName(segment) != null\n  );\n}\n\nfunction encodeURIComponentPreservingBrackets(str: string) {\n  return encodeURIComponent(str).replace(/%5B/g, '[').replace(/%5D/g, ']');\n}\n\n/**\n * Utility to serialize a navigation state object to a path string.\n *\n * @example\n * ```js\n * getPathFromState(\n *   {\n *     routes: [\n *       {\n *         name: 'Chat',\n *         params: { author: 'Jane', id: 42 },\n *       },\n *     ],\n *   },\n *   {\n *     screens: {\n *       Chat: {\n *         path: 'chat/:author/:id',\n *         stringify: { author: author => author.toLowerCase() }\n *       }\n *     }\n *   }\n * )\n * ```\n *\n * @param state Navigation state to serialize.\n * @param options Extra options to fine-tune how to serialize the path.\n * @returns Path representing the state, e.g. /foo/bar?count=42.\n */\nexport default function getPathFromState<ParamList extends object>(\n  state: State,\n  _options?: Options<ParamList> & {\n    preserveGroups?: boolean;\n    preserveDynamicRoutes?: boolean;\n  }\n): string {\n  return getPathDataFromState(state, _options).path;\n}\n\nexport function getPathDataFromState<ParamList extends object>(\n  state: State,\n  _options: Options<ParamList> & {\n    preserveGroups?: boolean;\n    preserveDynamicRoutes?: boolean;\n  } = { screens: DEFAULT_SCREENS }\n) {\n  if (state == null) {\n    throw Error(\"Got 'undefined' for the navigation state. You must pass a valid state object.\");\n  }\n\n  const { preserveGroups, preserveDynamicRoutes, ...options } = _options;\n\n  validatePathConfig(options);\n\n  // Expo Router disallows usage without a linking config.\n  if (Object.is(options.screens, DEFAULT_SCREENS)) {\n    throw Error(\"You must pass a 'screens' object to 'getPathFromState' to generate a path.\");\n  }\n\n  return getPathFromResolvedState(\n    JSON.parse(JSON.stringify(state)),\n    // Create a normalized configs object which will be easier to use\n    createNormalizedConfigs(options.screens),\n    { preserveGroups, preserveDynamicRoutes }\n  );\n}\n\nfunction processParamsWithUserSettings(configItem: ConfigItem, params: Record<string, any>) {\n  const stringify = configItem?.stringify;\n\n  return Object.fromEntries(\n    Object.entries(params).map(([key, value]) => [\n      key,\n      // TODO: Strip nullish values here.\n      stringify?.[key]\n        ? stringify[key](value)\n        : // Preserve rest params\n        Array.isArray(value)\n        ? value\n        : String(value),\n    ])\n  );\n}\n\nexport function deepEqual(a: any, b: any) {\n  if (a === b) {\n    return true;\n  }\n\n  if (Array.isArray(a) && Array.isArray(b)) {\n    if (a.length !== b.length) {\n      return false;\n    }\n\n    for (let i = 0; i < a.length; i++) {\n      if (!deepEqual(a[i], b[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  if (typeof a === 'object' && typeof b === 'object') {\n    const keysA = Object.keys(a);\n    const keysB = Object.keys(b);\n\n    if (keysA.length !== keysB.length) {\n      return false;\n    }\n\n    for (const key of keysA) {\n      if (!deepEqual(a[key], b[key])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  return false;\n}\n\nfunction walkConfigItems(\n  route: CustomRoute,\n  focusedRoute: {\n    name: string;\n    params?: object;\n  },\n  configs: Record<string, ConfigItem>,\n  {\n    preserveDynamicRoutes,\n  }: {\n    preserveDynamicRoutes?: boolean;\n  }\n) {\n  // NOTE(EvanBacon): Fill in current route using state that was passed as params.\n  if (!route.state && isInvalidParams(route.params)) {\n    route.state = createFakeState(route.params);\n  }\n\n  let pattern: string | null = null;\n  let focusedParams: Record<string, any> | undefined;\n\n  const collectedParams: Record<string, any> = {};\n\n  while (route.name in configs) {\n    const configItem = configs[route.name];\n    const inputPattern = configItem.pattern;\n\n    if (inputPattern == null) {\n      // This should never happen in Expo Router.\n      throw new Error('Unexpected: No pattern found for route ' + route.name);\n    }\n    pattern = inputPattern;\n\n    if (route.params) {\n      const params = processParamsWithUserSettings(configItem, route.params);\n      if (pattern !== undefined && pattern !== null) {\n        Object.assign(collectedParams, params);\n      }\n      if (deepEqual(focusedRoute, route)) {\n        if (preserveDynamicRoutes) {\n          focusedParams = params;\n        } else {\n          // If this is the focused route, keep the params for later use\n          // We save it here since it's been stringified already\n          focusedParams = getParamsWithConventionsCollapsed({\n            params,\n            pattern,\n            routeName: route.name,\n          });\n        }\n      }\n    }\n\n    if (!route.state && isInvalidParams(route.params)) {\n      route.state = createFakeState(route.params);\n    }\n\n    // If there is no `screens` property or no nested state, we return pattern\n    if (!configItem.screens || route.state === undefined) {\n      if (\n        configItem.initialRouteName &&\n        configItem.screens &&\n        configItem.initialRouteName in configItem.screens &&\n        configItem.screens[configItem.initialRouteName]?.pattern\n      ) {\n        const initialRouteConfig = configItem.screens[configItem.initialRouteName];\n\n        // NOTE(EvanBacon): Big hack to support initial route changes in tab bars.\n        pattern = initialRouteConfig.pattern!;\n        if (focusedParams) {\n          if (!preserveDynamicRoutes) {\n            // If this is the focused route, keep the params for later use\n            // We save it here since it's been stringified already\n            focusedParams = getParamsWithConventionsCollapsed({\n              params: focusedParams,\n              pattern,\n              routeName: route.name,\n            });\n          }\n        }\n      }\n      break;\n    }\n\n    const index = route.state.index ?? route.state.routes.length - 1;\n\n    const nextRoute = route.state.routes[index];\n    const nestedScreens = configItem.screens;\n\n    // if there is config for next route name, we go deeper\n    if (nestedScreens && nextRoute.name in nestedScreens) {\n      route = nextRoute as CustomRoute;\n      configs = nestedScreens;\n    } else {\n      // If not, there is no sense in going deeper in config\n      break;\n    }\n  }\n\n  if (pattern == null) {\n    throw new Error(\n      `No pattern found for route \"${route.name}\". Options are: ${Object.keys(configs).join(', ')}.`\n    );\n  }\n\n  if (pattern && !focusedParams && focusedRoute.params) {\n    if (preserveDynamicRoutes) {\n      focusedParams = focusedRoute.params;\n    } else {\n      // If this is the focused route, keep the params for later use\n      // We save it here since it's been stringified already\n      focusedParams = getParamsWithConventionsCollapsed({\n        params: focusedRoute.params,\n        pattern,\n        routeName: route.name,\n      });\n    }\n    Object.assign(focusedParams, collectedParams);\n  }\n\n  return {\n    pattern,\n    nextRoute: route,\n    focusedParams,\n    params: collectedParams,\n  };\n}\n\nfunction getPathFromResolvedState(\n  state: State,\n  configs: Record<string, ConfigItem>,\n  {\n    preserveGroups,\n    preserveDynamicRoutes,\n  }: { preserveGroups?: boolean; preserveDynamicRoutes?: boolean }\n) {\n  let path = '';\n  let current: State = state;\n\n  const allParams: Record<string, any> = {};\n\n  while (current) {\n    path += '/';\n\n    // Make mutable copies to ensure we don't leak state outside of the function.\n    const route = current.routes[current.index ?? 0] as CustomRoute;\n\n    // NOTE(EvanBacon): Fill in current route using state that was passed as params.\n    // if (isInvalidParams(route.params)) {\n    if (!route.state && isInvalidParams(route.params)) {\n      route.state = createFakeState(route.params);\n    }\n\n    const { pattern, params, nextRoute, focusedParams } = walkConfigItems(\n      route,\n      getActiveRoute(current),\n      { ...configs },\n      { preserveDynamicRoutes }\n    );\n\n    Object.assign(allParams, params);\n\n    path += getPathWithConventionsCollapsed({\n      pattern,\n      routePath: nextRoute.path,\n      params: allParams,\n      initialRouteName: configs[nextRoute.name]?.initialRouteName,\n      preserveGroups,\n      preserveDynamicRoutes,\n    });\n\n    if (\n      nextRoute.state &&\n      // NOTE(EvanBacon): The upstream implementation allows for sending in synthetic states (states that weren't generated by `getStateFromPath`)\n      // and any invalid routes will simply be ignored.\n      // Because of this, we need to check if the next route is valid before continuing, otherwise our more strict\n      // implementation will throw an error.\n      configs[nextRoute.state.routes?.[nextRoute.state?.index ?? 0]?.name]\n    ) {\n      // Continue looping with the next state if available.\n      current = nextRoute.state;\n    } else {\n      // Finished crawling state.\n\n      // Check for query params before exiting.\n      if (focusedParams) {\n        for (const param in focusedParams) {\n          // TODO: This is not good. We shouldn't squat strings named \"undefined\".\n          if (focusedParams[param] === 'undefined') {\n            // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n            delete focusedParams[param];\n          }\n        }\n\n        const query = new URLSearchParams(focusedParams).toString();\n        if (query) {\n          path += `?${query}`;\n        }\n      }\n      break;\n    }\n  }\n\n  return { path: appendBaseUrl(basicSanitizePath(path)), params: decodeParams(allParams) };\n}\n\nfunction decodeParams(params: Record<string, string>) {\n  const parsed: Record<string, any> = {};\n\n  for (const [key, value] of Object.entries(params)) {\n    try {\n      if (Array.isArray(value)) {\n        parsed[key] = value.map((v) => decodeURIComponent(v));\n      } else {\n        parsed[key] = decodeURIComponent(value);\n      }\n    } catch {\n      parsed[key] = value;\n    }\n  }\n\n  return parsed;\n}\n\nfunction getPathWithConventionsCollapsed({\n  pattern,\n  routePath,\n  params,\n  preserveGroups,\n  preserveDynamicRoutes,\n  initialRouteName,\n}: {\n  pattern: string;\n  routePath?: string;\n  params: Record<string, any>;\n  preserveGroups?: boolean;\n  preserveDynamicRoutes?: boolean;\n  initialRouteName?: string;\n}) {\n  const segments = pattern.split('/');\n  return segments\n    .map((p, i) => {\n      const name = getParamName(p);\n\n      // We don't know what to show for wildcard patterns\n      // Showing the route name seems ok, though whatever we show here will be incorrect\n      // Since the page doesn't actually exist\n      if (p.startsWith('*')) {\n        if (preserveDynamicRoutes) {\n          if (name === 'not-found') {\n            return '+not-found';\n          }\n          return `[...${name}]`;\n        }\n        if (params[name]) {\n          if (Array.isArray(params[name])) {\n            return params[name].join('/');\n          }\n          return params[name];\n        }\n        if (i === 0) {\n          // This can occur when a wildcard matches all routes and the given path was `/`.\n          return routePath;\n        }\n        // remove existing segments from route.path and return it\n        // this is used for nested wildcard routes. Without this, the path would add\n        // all nested segments to the beginning of the wildcard route.\n        return routePath\n          ?.split('/')\n          .slice(i + 1)\n          .join('/');\n      }\n\n      // If the path has a pattern for a param, put the param in the path\n      if (p.startsWith(':')) {\n        if (preserveDynamicRoutes) {\n          return `[${name}]`;\n        }\n        // Optional params without value assigned in route.params should be ignored\n        return params[name];\n      }\n\n      if (!preserveGroups && matchGroupName(p) != null) {\n        // When the last part is a group it could be a shared URL\n        // if the route has an initialRouteName defined, then we should\n        // use that as the component path as we can assume it will be shown.\n        if (segments.length - 1 === i) {\n          if (initialRouteName) {\n            // Return an empty string if the init route is ambiguous.\n            if (segmentMatchesConvention(initialRouteName)) {\n              return '';\n            }\n            return encodeURIComponentPreservingBrackets(initialRouteName);\n          }\n        }\n        return '';\n      }\n      // Preserve dynamic syntax for rehydration\n      return encodeURIComponentPreservingBrackets(p);\n    })\n    .map((v) => v ?? '')\n    .join('/');\n}\n\n/** Given a set of query params and a pattern with possible conventions, collapse the conventions and return the remaining params. */\nfunction getParamsWithConventionsCollapsed({\n  pattern,\n  routeName,\n  params,\n}: {\n  pattern: string;\n  /** Route name is required for matching the wildcard route. This is specific to Expo Router. */\n  routeName: string;\n  params: object;\n}): Record<string, string> {\n  const processedParams: Record<string, string> = { ...params };\n\n  // Remove the params present in the pattern since we'll only use the rest for query string\n\n  const segments = pattern.split('/');\n\n  // Dynamic Routes\n  segments\n    .filter((segment) => segment.startsWith(':'))\n    .forEach((segment) => {\n      const name = getParamName(segment);\n      delete processedParams[name];\n    });\n\n  // Deep Dynamic Routes\n  if (segments.some((segment) => segment.startsWith('*'))) {\n    // NOTE(EvanBacon): Drop the param name matching the wildcard route name -- this is specific to Expo Router.\n    const name = testNotFound(routeName)\n      ? 'not-found'\n      : matchDeepDynamicRouteName(routeName) ?? routeName;\n    delete processedParams[name];\n  }\n\n  return processedParams;\n}\n\n// Remove multiple as well as trailing slashes\nfunction basicSanitizePath(path: string) {\n  // Remove duplicate slashes like `foo//bar` -> `foo/bar`\n  const simplifiedPath = path.replace(/\\/+/g, '/');\n  if (simplifiedPath.length <= 1) {\n    return simplifiedPath;\n  }\n  // Remove trailing slash like `foo/bar/` -> `foo/bar`\n  return simplifiedPath.replace(/\\/$/, '');\n}\n\ntype StateAsParams = {\n  initial: boolean;\n  path?: string;\n  screen: string;\n  params: Record<string, any>;\n};\n\n// TODO: Make StackRouter not do this...\n// Detect if the params came from StackRouter using `params` to pass around internal state.\nfunction isInvalidParams(params?: Record<string, any>): params is StateAsParams {\n  if (!params) {\n    return false;\n  }\n\n  if ('params' in params && typeof params.params === 'object' && !!params.params) {\n    return true;\n  }\n\n  return (\n    'initial' in params &&\n    typeof params.initial === 'boolean' &&\n    // \"path\" in params &&\n    'screen' in params\n  );\n}\n\nconst getParamName = (pattern: string) => pattern.replace(/^[:*]/, '').replace(/\\?$/, '');\n\nconst joinPaths = (...paths: string[]): string =>\n  ([] as string[])\n    .concat(...paths.map((p) => p.split('/')))\n    .filter(Boolean)\n    .join('/');\n\nconst createConfigItem = (\n  config: PathConfig<object> | string,\n  parentPattern?: string\n): ConfigItem => {\n  if (typeof config === 'string') {\n    // If a string is specified as the value of the key(e.g. Foo: '/path'), use it as the pattern\n    const pattern = parentPattern ? joinPaths(parentPattern, config) : config;\n\n    return { pattern };\n  }\n\n  if (config.exact && config.path === undefined) {\n    throw new Error(\n      \"A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. `path: ''`.\"\n    );\n  }\n\n  // If an object is specified as the value (e.g. Foo: { ... }),\n  // It can have `path` property and `screens` prop which has nested configs\n  const pattern =\n    config.exact !== true ? joinPaths(parentPattern || '', config.path || '') : config.path || '';\n\n  const screens = config.screens ? createNormalizedConfigs(config.screens, pattern) : undefined;\n\n  return {\n    // Normalize pattern to remove any leading, trailing slashes, duplicate slashes etc.\n    pattern: pattern?.split('/').filter(Boolean).join('/'),\n    stringify: config.stringify,\n    screens,\n    initialRouteName: config.initialRouteName,\n  };\n};\n\nconst createNormalizedConfigs = (\n  options: PathConfigMap<object>,\n  pattern?: string\n): Record<string, ConfigItem> =>\n  Object.fromEntries(\n    Object.entries(options).map(([name, c]) => [name, createConfigItem(c, pattern)])\n  );\n\nexport function appendBaseUrl(\n  path: string,\n  baseUrl: string | undefined = process.env.EXPO_BASE_URL\n) {\n  if (process.env.NODE_ENV !== 'development') {\n    if (baseUrl) {\n      return `/${baseUrl.replace(/^\\/+/, '').replace(/\\/$/, '')}${path}`;\n    }\n  }\n  return path;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}