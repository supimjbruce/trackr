{"ast":null,"code":"\"use strict\";\n\nvar _objectWithoutProperties = require(\"@babel/runtime/helpers/objectWithoutProperties\");\nvar _slicedToArray = require(\"@babel/runtime/helpers/slicedToArray\");\nvar _defineProperty = require(\"@babel/runtime/helpers/defineProperty\");\nvar _toConsumableArray = require(\"@babel/runtime/helpers/toConsumableArray\");\nvar _excluded = [\"filePath\"];\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getUserDefinedTopLevelNotFoundRoute = exports.getExactRoutes = exports.getRoutes = exports.assertDuplicateRoutes = exports.generateDynamic = exports.generateDynamicFromSegment = exports.getRecursiveTree = void 0;\nvar import_mode_1 = __importDefault(require(\"./import-mode\"));\nvar matchers_1 = require(\"./matchers\");\nfunction getRecursiveTree(files) {\n  var tree = {\n    name: '',\n    children: [],\n    parents: [],\n    node: null\n  };\n  for (var file of files) {\n    var parts = file.normalizedName.split('/');\n    var currentNode = tree;\n    var _loop = function _loop() {\n      var part = parts[i];\n      if (i === parts.length - 1 && part === '_layout') {\n        if (currentNode.node) {\n          var overwritten = currentNode.node.contextKey;\n          throw new Error(`Higher priority Layout Route \"${file.contextKey}\" overriding redundant Layout Route \"${overwritten}\". Remove the Layout Route \"${overwritten}\" to fix this.`);\n        }\n        return 1;\n      }\n      var existing = currentNode.children.find(function (item) {\n        return item.name === part;\n      });\n      if (existing) {\n        currentNode = existing;\n      } else {\n        var newNode = {\n          name: part,\n          children: [],\n          parents: [].concat(_toConsumableArray(currentNode.parents), [currentNode.name]),\n          node: null\n        };\n        currentNode.children.push(newNode);\n        currentNode = newNode;\n      }\n    };\n    for (var i = 0; i < parts.length; i++) {\n      if (_loop()) continue;\n    }\n    currentNode.node = file;\n  }\n  if (process.env.NODE_ENV !== 'production') {\n    assertDeprecatedFormat(tree);\n  }\n  return tree;\n}\nexports.getRecursiveTree = getRecursiveTree;\nfunction assertDeprecatedFormat(tree) {\n  for (var child of tree.children) {\n    if (child.node && child.children.length && !child.node.normalizedName.endsWith('_layout')) {\n      var ext = child.node.contextKey.split('.').pop();\n      throw new Error(`Using deprecated Layout Route format: Move \\`./app/${child.node.normalizedName}.${ext}\\` to \\`./app/${child.node.normalizedName}/_layout.${ext}\\``);\n    }\n    assertDeprecatedFormat(child);\n  }\n}\nfunction getTreeNodesAsRouteNodes(nodes, options) {\n  return nodes.map(function (node) {\n    return treeNodeToRouteNode(node, options);\n  }).flat().filter(Boolean);\n}\nfunction generateDynamicFromSegment(name) {\n  if (name === '+not-found') {\n    return {\n      name: '+not-found',\n      deep: true,\n      notFound: true\n    };\n  }\n  var deepDynamicName = (0, matchers_1.matchDeepDynamicRouteName)(name);\n  var dynamicName = deepDynamicName != null ? deepDynamicName : (0, matchers_1.matchDynamicName)(name);\n  if (!dynamicName) {\n    return null;\n  }\n  return {\n    name: dynamicName,\n    deep: !!deepDynamicName\n  };\n}\nexports.generateDynamicFromSegment = generateDynamicFromSegment;\nfunction generateDynamic(name) {\n  var description = name.split('/').map(function (segment) {\n    return generateDynamicFromSegment(segment);\n  }).filter(Boolean);\n  return description.length === 0 ? null : description;\n}\nexports.generateDynamic = generateDynamic;\nfunction collapseRouteSegments(route) {\n  return (0, matchers_1.stripGroupSegmentsFromPath)(route.replace(/\\/index$/, ''));\n}\nfunction getDefaultInitialRoute(node, name) {\n  return node.children.find(function (node) {\n    return collapseRouteSegments(node.route) === name;\n  });\n}\nfunction applyDefaultInitialRouteName(node) {\n  var _node$children, _getDefaultInitialRou;\n  var groupName = (0, matchers_1.matchGroupName)(node.route);\n  if (!((_node$children = node.children) != null && _node$children.length)) {\n    return node;\n  }\n  var initialRouteName = groupName ? (_getDefaultInitialRou = getDefaultInitialRoute(node, groupName)) == null ? void 0 : _getDefaultInitialRou.route : undefined;\n  var loaded = node.loadRoute();\n  if (loaded != null && loaded.unstable_settings) {\n    var _loaded$unstable_sett;\n    initialRouteName = (_loaded$unstable_sett = loaded.unstable_settings.initialRouteName) != null ? _loaded$unstable_sett : initialRouteName;\n    if (groupName) {\n      var _loaded$unstable_sett2, _loaded$unstable_sett3;\n      var groupSpecificInitialRouteName = (_loaded$unstable_sett2 = loaded.unstable_settings) == null ? void 0 : (_loaded$unstable_sett3 = _loaded$unstable_sett2[groupName]) == null ? void 0 : _loaded$unstable_sett3.initialRouteName;\n      initialRouteName = groupSpecificInitialRouteName != null ? groupSpecificInitialRouteName : initialRouteName;\n    }\n  }\n  return _objectSpread(_objectSpread({}, node), {}, {\n    initialRouteName: initialRouteName\n  });\n}\nfunction folderNodeToRouteNode(_ref, options) {\n  var name = _ref.name,\n    children = _ref.children;\n  if (!children.length) {\n    return null;\n  }\n  return getTreeNodesAsRouteNodes(children.map(function (child) {\n    return _objectSpread(_objectSpread({}, child), {}, {\n      name: [name, child.name].filter(Boolean).join('/')\n    });\n  }), options);\n}\nfunction fileNodeToRouteNode(tree, options) {\n  var name = tree.name,\n    node = tree.node,\n    children = tree.children;\n  if (!node) throw new Error('node must be defined');\n  var dynamic = generateDynamic(name);\n  var clones = extrapolateGroupRoutes(name, node.contextKey);\n  clones.delete(name);\n  var output = {\n    loadRoute: node.loadRoute,\n    route: name,\n    contextKey: node.contextKey,\n    children: getTreeNodesAsRouteNodes(children, options),\n    dynamic: dynamic,\n    filePath: node.filePath,\n    entryPoints: options.ignoreEntryPoints || isApiRoutePath(node.contextKey) ? undefined : [node.filePath]\n  };\n  if (clones.size) {\n    return _toConsumableArray(clones).map(function (clone) {\n      return applyDefaultInitialRouteName(_objectSpread(_objectSpread({}, output), {}, {\n        contextKey: node.contextKey.replace(output.route, clone),\n        route: clone\n      }));\n    });\n  }\n  return [applyDefaultInitialRouteName({\n    loadRoute: node.loadRoute,\n    route: name,\n    entryPoints: options.ignoreEntryPoints || isApiRoutePath(node.contextKey) ? undefined : [node.filePath],\n    filePath: node.filePath,\n    contextKey: node.contextKey,\n    children: getTreeNodesAsRouteNodes(children, options),\n    dynamic: dynamic\n  })];\n}\nfunction extrapolateGroupRoutes(route, contextKey) {\n  var routes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Set();\n  var match = (0, matchers_1.matchGroupName)(route);\n  if (!match) {\n    routes.add(route);\n    return routes;\n  }\n  var groups = match == null ? void 0 : match.split(',');\n  var groupsSet = new Set(groups);\n  if (groupsSet.size !== groups.length) {\n    throw new Error(`Array syntax cannot contain duplicate group name \"${groups}\" in \"${contextKey}\".`);\n  }\n  if (groups.length === 1) {\n    routes.add(route);\n    return routes;\n  }\n  for (var group of groups) {\n    extrapolateGroupRoutes(route.replace(match, group.trim()), contextKey, routes);\n  }\n  return routes;\n}\nfunction treeNodeToRouteNode(tree, options) {\n  if (tree.node) {\n    return fileNodeToRouteNode(tree, options);\n  }\n  return folderNodeToRouteNode(tree, options);\n}\nfunction contextModuleToFileNodes(contextModule) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var files = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : contextModule.keys();\n  var nodes = files.map(function (key) {\n    if (process.env.NODE_ENV === 'development') {\n      if (import_mode_1.default === 'sync') {\n        var _contextModule;\n        var isApi = key.match(/\\+api\\.[jt]sx?$/);\n        if (!isApi && !((_contextModule = contextModule(key)) != null && _contextModule.default)) {\n          return null;\n        }\n      }\n    }\n    var node = {\n      loadRoute: function loadRoute() {\n        if (options.ignoreRequireErrors) {\n          try {\n            return contextModule(key);\n          } catch (_unused) {\n            return {};\n          }\n        } else {\n          return contextModule(key);\n        }\n      },\n      normalizedName: (0, matchers_1.getNameFromFilePath)(key),\n      filePath: key,\n      contextKey: key\n    };\n    return node;\n  });\n  return nodes.filter(Boolean);\n}\nfunction hasCustomRootLayoutNode(routes) {\n  if (routes.length !== 1) {\n    return false;\n  }\n  var route = routes[0];\n  if (route.route === '' && route.contextKey.match(/^\\.\\/_layout\\.([jt]sx?)$/)) {\n    return true;\n  }\n  return false;\n}\nfunction treeNodesToRootRoute(treeNode, options) {\n  var routes = treeNodeToRouteNode(treeNode, options);\n  return withOptionalRootLayout(routes);\n}\nfunction processKeys(files, options) {\n  var ignore = options.ignore;\n  return files.filter(function (file) {\n    return !(ignore != null && ignore.some(function (pattern) {\n      return pattern.test(file);\n    }));\n  });\n}\nfunction assertDuplicateRoutes(filenames) {\n  if (process.env.NODE_ENV === 'production') {\n    return;\n  }\n  var duplicates = filenames.map(function (filename) {\n    return (0, matchers_1.removeSupportedExtensions)(filename);\n  }).reduce(function (acc, filename) {\n    acc[filename] = acc[filename] ? acc[filename] + 1 : 1;\n    return acc;\n  }, {});\n  Object.entries(duplicates).forEach(function (_ref2) {\n    var _ref3 = _slicedToArray(_ref2, 2),\n      filename = _ref3[0],\n      count = _ref3[1];\n    if (count > 1) {\n      throw new Error(`Multiple files match the route name \"${filename}\".`);\n    }\n  });\n}\nexports.assertDuplicateRoutes = assertDuplicateRoutes;\nfunction getRoutes(contextModule, options) {\n  var route = getExactRoutesInternal(contextModule, options);\n  if (!route) {\n    return null;\n  }\n  appendSitemapRoute(route);\n  appendUnmatchedRoute(route);\n  if (options != null && options.ignoreEntryPoints) {\n    return removeFilePath(route);\n  }\n  return removeFilePath(crawlAndAppendEntryFilesForInitialRoutes(crawlAndAppendEntryFiles(route)));\n}\nexports.getRoutes = getRoutes;\nfunction removeFilePath(route) {\n  if (!route) return route;\n  var filePath = route.filePath,\n    rest = _objectWithoutProperties(route, _excluded);\n  return _objectSpread(_objectSpread({}, rest), {}, {\n    children: route.children.map(function (child) {\n      return removeFilePath(child);\n    }).filter(Boolean)\n  });\n}\nfunction unique(array) {\n  return _toConsumableArray(new Set(array));\n}\nfunction isLayoutRoute(route) {\n  return route.contextKey.match(/\\/_layout\\.([jt]sx?)$/);\n}\nfunction isViewRoute(route) {\n  return !!route && !isApiRoute(route);\n}\nfunction isApiRoute(route) {\n  return isApiRoutePath(route.contextKey);\n}\nfunction isApiRoutePath(route) {\n  return !!route.match(/\\+api\\.[jt]sx?$/);\n}\nfunction crawlAndAppendEntryFiles(route) {\n  var _route$entryPoints;\n  var entryPoints = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  if (!isViewRoute(route)) {\n    return null;\n  }\n  var nextEntryPoints = unique([].concat(_toConsumableArray(entryPoints), _toConsumableArray((_route$entryPoints = route.entryPoints) != null ? _route$entryPoints : []), [route.filePath]));\n  route.children.forEach(function (child) {\n    crawlAndAppendEntryFiles(child, nextEntryPoints);\n  });\n  if (isLayoutRoute(route)) {\n    delete route.entryPoints;\n  } else {\n    route.entryPoints = nextEntryPoints;\n  }\n  return route;\n}\nfunction crawlAndAppendEntryFilesForInitialRoutes(route) {\n  var initialRoutes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  if (!isViewRoute(route)) {\n    return null;\n  }\n  if (isLayoutRoute(route)) {\n    if (route.initialRouteName) {\n      var initialRoute = route.children.find(function (child) {\n        return child.route === route.initialRouteName;\n      });\n      if (!initialRoute) {\n        throw new Error(`Invalid initialRouteName \"${route.initialRouteName}\" defined in ${route.filePath}. Options are: ${route.children.map(function (route) {\n          return route.route;\n        }).join(', ')}`);\n      }\n      route.children.forEach(function (child) {\n        crawlAndAppendEntryFilesForInitialRoutes(child, [].concat(_toConsumableArray(initialRoutes), [initialRoute]));\n      });\n    }\n  } else {\n    var isInitial = initialRoutes.some(function (initialRoute) {\n      return initialRoute.contextKey === route.contextKey;\n    });\n    if (!isInitial) {\n      var _route$entryPoints3;\n      route.entryPoints = unique([].concat(_toConsumableArray(initialRoutes.map(function (route) {\n        var _route$entryPoints2;\n        return (_route$entryPoints2 = route.entryPoints) != null ? _route$entryPoints2 : [];\n      }).flat()), _toConsumableArray((_route$entryPoints3 = route.entryPoints) != null ? _route$entryPoints3 : [])));\n    }\n  }\n  return route;\n}\nfunction getIgnoreList(options) {\n  var _options$ignore;\n  var ignore = [/^\\.\\/\\+html\\.[tj]sx?$/].concat(_toConsumableArray((_options$ignore = options == null ? void 0 : options.ignore) != null ? _options$ignore : []));\n  if ((options == null ? void 0 : options.preserveApiRoutes) !== true) {\n    ignore.push(/\\+api\\.[tj]sx?$/);\n  }\n  return ignore;\n}\nfunction getExactRoutesInternal(contextModule) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var treeNodes = contextModuleToTree(contextModule, options);\n  return treeNodesToRootRoute(treeNodes, options);\n}\nfunction getExactRoutes(contextModule, options) {\n  var route = getExactRoutesInternal(contextModule, options);\n  if (!(options != null && options.ignoreEntryPoints)) {\n    return removeFilePath(crawlAndAppendEntryFilesForInitialRoutes(crawlAndAppendEntryFiles(route)));\n  }\n  return removeFilePath(route);\n}\nexports.getExactRoutes = getExactRoutes;\nfunction contextModuleToTree(contextModule, options) {\n  var allowed = processKeys(contextModule.keys(), _objectSpread(_objectSpread({}, options), {}, {\n    ignore: getIgnoreList(options)\n  }));\n  assertDuplicateRoutes(allowed);\n  var files = contextModuleToFileNodes(contextModule, options, allowed);\n  return getRecursiveTree(files);\n}\nfunction appendSitemapRoute(routes) {\n  if (!routes.children.length || routes.children.some(function (route) {\n    return route.route === '_sitemap';\n  })) {\n    return routes;\n  }\n  routes.children.push({\n    loadRoute: function loadRoute() {\n      var _require = require('./views/Sitemap'),\n        Sitemap = _require.Sitemap,\n        getNavOptions = _require.getNavOptions;\n      return {\n        default: Sitemap,\n        getNavOptions: getNavOptions\n      };\n    },\n    filePath: 'expo-router/build/views/Sitemap.js',\n    route: '_sitemap',\n    contextKey: './_sitemap.tsx',\n    generated: true,\n    internal: true,\n    dynamic: null,\n    children: []\n  });\n  return routes;\n}\nfunction appendUnmatchedRoute(routes) {\n  var userDefinedDynamicRoute = getUserDefinedTopLevelNotFoundRoute(routes);\n  if (!userDefinedDynamicRoute) {\n    routes.children.push({\n      loadRoute: function loadRoute() {\n        return {\n          default: require('./views/Unmatched').Unmatched\n        };\n      },\n      filePath: 'expo-router/build/views/Unmatched.js',\n      route: '+not-found',\n      contextKey: './+not-found.tsx',\n      dynamic: [{\n        name: '+not-found',\n        deep: true,\n        notFound: true\n      }],\n      children: [],\n      generated: true,\n      internal: true\n    });\n  }\n  return routes;\n}\nfunction getUserDefinedTopLevelNotFoundRoute(routes) {\n  for (var route of (_routes$children = routes == null ? void 0 : routes.children) != null ? _routes$children : []) {\n    var _routes$children;\n    if (route.generated) continue;\n    var isDeepDynamic = (0, matchers_1.stripGroupSegmentsFromPath)(route.route) === '+not-found' && route.route.match(/\\+not-found$/);\n    if (isDeepDynamic) {\n      return route;\n    }\n    if ((0, matchers_1.matchGroupName)(route.route)) {\n      var child = getUserDefinedTopLevelNotFoundRoute(route);\n      if (child) {\n        return child;\n      }\n    }\n  }\n  return null;\n}\nexports.getUserDefinedTopLevelNotFoundRoute = getUserDefinedTopLevelNotFoundRoute;\nfunction withOptionalRootLayout(routes) {\n  if (!(routes != null && routes.length)) {\n    return null;\n  }\n  if (hasCustomRootLayoutNode(routes)) {\n    return routes[0];\n  }\n  return {\n    loadRoute: function loadRoute() {\n      return {\n        default: require('./views/Navigator').DefaultNavigator\n      };\n    },\n    filePath: 'expo-router/build/views/Navigator.js',\n    contextKey: './_layout.tsx',\n    route: '',\n    generated: true,\n    dynamic: null,\n    children: routes\n  };\n}","map":{"version":3,"names":["import_mode_1","__importDefault","require","matchers_1","getRecursiveTree","files","tree","name","children","parents","node","file","parts","normalizedName","split","currentNode","_loop","part","i","length","overwritten","contextKey","Error","existing","find","item","newNode","concat","_toConsumableArray","push","process","env","NODE_ENV","assertDeprecatedFormat","exports","child","endsWith","ext","pop","getTreeNodesAsRouteNodes","nodes","options","map","treeNodeToRouteNode","flat","filter","Boolean","generateDynamicFromSegment","deep","notFound","deepDynamicName","matchDeepDynamicRouteName","dynamicName","matchDynamicName","generateDynamic","description","segment","collapseRouteSegments","route","stripGroupSegmentsFromPath","replace","getDefaultInitialRoute","applyDefaultInitialRouteName","_node$children","_getDefaultInitialRou","groupName","matchGroupName","initialRouteName","undefined","loaded","loadRoute","unstable_settings","_loaded$unstable_sett","_loaded$unstable_sett2","_loaded$unstable_sett3","groupSpecificInitialRouteName","_objectSpread","folderNodeToRouteNode","_ref","join","fileNodeToRouteNode","dynamic","clones","extrapolateGroupRoutes","delete","output","filePath","entryPoints","ignoreEntryPoints","isApiRoutePath","size","clone","routes","arguments","Set","match","add","groups","groupsSet","group","trim","contextModuleToFileNodes","contextModule","keys","key","default","_contextModule","isApi","ignoreRequireErrors","_unused","getNameFromFilePath","hasCustomRootLayoutNode","treeNodesToRootRoute","treeNode","withOptionalRootLayout","processKeys","ignore","some","pattern","test","assertDuplicateRoutes","filenames","duplicates","filename","removeSupportedExtensions","reduce","acc","Object","entries","forEach","_ref2","_ref3","_slicedToArray","count","getRoutes","getExactRoutesInternal","appendSitemapRoute","appendUnmatchedRoute","removeFilePath","crawlAndAppendEntryFilesForInitialRoutes","crawlAndAppendEntryFiles","rest","_objectWithoutProperties","_excluded","unique","array","isLayoutRoute","isViewRoute","isApiRoute","_route$entryPoints","nextEntryPoints","initialRoutes","initialRoute","isInitial","_route$entryPoints3","_route$entryPoints2","getIgnoreList","_options$ignore","preserveApiRoutes","treeNodes","contextModuleToTree","getExactRoutes","allowed","_require","Sitemap","getNavOptions","generated","internal","userDefinedDynamicRoute","getUserDefinedTopLevelNotFoundRoute","Unmatched","_routes$children","isDeepDynamic","DefaultNavigator"],"sources":["/Users/jonathanbruce/Coding/trackr/node_modules/expo-router/src/getRoutes.ts"],"sourcesContent":["import type { DynamicConvention, RouteNode } from './Route';\nimport EXPO_ROUTER_IMPORT_MODE from './import-mode';\nimport {\n  getNameFromFilePath,\n  matchDeepDynamicRouteName,\n  matchDynamicName,\n  matchGroupName,\n  removeSupportedExtensions,\n  stripGroupSegmentsFromPath,\n} from './matchers';\nimport type { RequireContext } from './types';\n\nexport type FileNode = Pick<IntermediateRouteNode, 'contextKey' | 'loadRoute' | 'filePath'> & {\n  /** Like `(tab)/index` */\n  normalizedName: string;\n};\n\ntype IntermediateRouteNode = Omit<RouteNode, 'children'> & {\n  filePath: string;\n  children: IntermediateRouteNode[];\n};\n\ntype TreeNode = {\n  name: string;\n  children: TreeNode[];\n  parents: string[];\n  /** null when there is no file in a folder. */\n  node: FileNode | null;\n};\n\ntype Options = {\n  ignore?: RegExp[];\n  preserveApiRoutes?: boolean;\n  ignoreRequireErrors?: boolean;\n  ignoreEntryPoints?: boolean;\n};\n\n/** Convert a flat map of file nodes into a nested tree of files. */\nexport function getRecursiveTree(files: FileNode[]): TreeNode {\n  const tree = {\n    name: '',\n    children: [],\n    parents: [],\n    node: null,\n  };\n\n  for (const file of files) {\n    // ['(tab)', 'settings', '[...another]']\n    const parts = file.normalizedName.split('/');\n    let currentNode: TreeNode = tree;\n    for (let i = 0; i < parts.length; i++) {\n      const part = parts[i];\n\n      if (i === parts.length - 1 && part === '_layout') {\n        if (currentNode.node) {\n          const overwritten = currentNode.node.contextKey;\n          throw new Error(\n            `Higher priority Layout Route \"${file.contextKey}\" overriding redundant Layout Route \"${overwritten}\". Remove the Layout Route \"${overwritten}\" to fix this.`\n          );\n        }\n        continue;\n      }\n\n      const existing = currentNode.children.find((item) => item.name === part);\n      if (existing) {\n        currentNode = existing;\n      } else {\n        const newNode: TreeNode = {\n          name: part,\n          children: [],\n          parents: [...currentNode.parents, currentNode.name],\n          node: null,\n        };\n        currentNode.children.push(newNode);\n        currentNode = newNode;\n      }\n    }\n    currentNode.node = file;\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    assertDeprecatedFormat(tree);\n  }\n\n  return tree;\n}\n\nfunction assertDeprecatedFormat(tree: TreeNode) {\n  for (const child of tree.children) {\n    if (child.node && child.children.length && !child.node.normalizedName.endsWith('_layout')) {\n      const ext = child.node.contextKey.split('.').pop();\n      throw new Error(\n        `Using deprecated Layout Route format: Move \\`./app/${child.node.normalizedName}.${ext}\\` to \\`./app/${child.node.normalizedName}/_layout.${ext}\\``\n      );\n    }\n    assertDeprecatedFormat(child);\n  }\n}\n\nfunction getTreeNodesAsRouteNodes(nodes: TreeNode[], options: Options): IntermediateRouteNode[] {\n  return nodes\n    .map((node) => treeNodeToRouteNode(node, options))\n    .flat()\n    .filter(Boolean) as IntermediateRouteNode[];\n}\n\nexport function generateDynamicFromSegment(name: string): DynamicConvention | null {\n  if (name === '+not-found') {\n    return {\n      name: '+not-found',\n      deep: true,\n      notFound: true,\n    };\n  }\n\n  const deepDynamicName = matchDeepDynamicRouteName(name);\n  const dynamicName = deepDynamicName ?? matchDynamicName(name);\n  if (!dynamicName) {\n    return null;\n  }\n  return { name: dynamicName, deep: !!deepDynamicName };\n}\n\nexport function generateDynamic(name: string): IntermediateRouteNode['dynamic'] {\n  const description = name\n    .split('/')\n    .map((segment) => generateDynamicFromSegment(segment))\n    .filter(Boolean) as DynamicConvention[];\n  return description.length === 0 ? null : description;\n}\n\nfunction collapseRouteSegments(route: string) {\n  return stripGroupSegmentsFromPath(route.replace(/\\/index$/, ''));\n}\n\n/**\n * Given a route node and a name representing the group name,\n * find the nearest child matching the name.\n *\n * Doesn't support slashes in the name.\n * Routes like `explore/(something)/index` will be matched against `explore`.\n *\n */\nfunction getDefaultInitialRoute(node: IntermediateRouteNode, name: string) {\n  return node.children.find((node) => collapseRouteSegments(node.route) === name);\n}\n\nfunction applyDefaultInitialRouteName(node: IntermediateRouteNode): IntermediateRouteNode {\n  const groupName = matchGroupName(node.route);\n  if (!node.children?.length) {\n    return node;\n  }\n\n  // Guess at the initial route based on the group name.\n  // TODO(EvanBacon): Perhaps we should attempt to warn when the group doesn't match any child routes.\n  let initialRouteName = groupName ? getDefaultInitialRoute(node, groupName)?.route : undefined;\n  const loaded = node.loadRoute();\n\n  if (loaded?.unstable_settings) {\n    // Allow unstable_settings={ initialRouteName: '...' } to override the default initial route name.\n    initialRouteName = loaded.unstable_settings.initialRouteName ?? initialRouteName;\n\n    if (groupName) {\n      // Allow unstable_settings={ 'custom': { initialRouteName: '...' } } to override the less specific initial route name.\n      const groupSpecificInitialRouteName = loaded.unstable_settings?.[groupName]?.initialRouteName;\n\n      initialRouteName = groupSpecificInitialRouteName ?? initialRouteName;\n    }\n  }\n\n  return {\n    ...node,\n    initialRouteName,\n  };\n}\n\nfunction folderNodeToRouteNode(\n  { name, children }: TreeNode,\n  options: Options\n): IntermediateRouteNode[] | null {\n  // Empty folder, skip it.\n  if (!children.length) {\n    return null;\n  }\n\n  // When there's a directory, but no layout route file (with valid export), the child routes won't be grouped.\n  // This pushes all children into the nearest layout route.\n  return getTreeNodesAsRouteNodes(\n    children.map((child) => {\n      return {\n        ...child,\n        name: [name, child.name].filter(Boolean).join('/'),\n      };\n    }),\n    options\n  );\n}\n\nfunction fileNodeToRouteNode(tree: TreeNode, options: Options): IntermediateRouteNode[] | null {\n  const { name, node, children } = tree;\n\n  if (!node) throw new Error('node must be defined');\n\n  const dynamic = generateDynamic(name);\n\n  const clones = extrapolateGroupRoutes(name, node.contextKey);\n  clones.delete(name);\n\n  const output = {\n    loadRoute: node.loadRoute,\n    route: name,\n    contextKey: node.contextKey,\n    children: getTreeNodesAsRouteNodes(children, options),\n    dynamic,\n    filePath: node.filePath,\n    entryPoints:\n      options.ignoreEntryPoints || isApiRoutePath(node.contextKey) ? undefined : [node.filePath],\n  };\n\n  if (clones.size) {\n    return [...clones].map((clone) =>\n      applyDefaultInitialRouteName({\n        ...output,\n        contextKey: node.contextKey.replace(output.route, clone),\n        route: clone,\n      })\n    );\n  }\n\n  return [\n    applyDefaultInitialRouteName({\n      loadRoute: node.loadRoute,\n      route: name,\n      entryPoints:\n        options.ignoreEntryPoints || isApiRoutePath(node.contextKey) ? undefined : [node.filePath],\n      filePath: node.filePath,\n      contextKey: node.contextKey,\n      children: getTreeNodesAsRouteNodes(children, options),\n      dynamic,\n    }),\n  ];\n}\n\nfunction extrapolateGroupRoutes(\n  route: string,\n  contextKey: string,\n  routes: Set<string> = new Set()\n): Set<string> {\n  const match = matchGroupName(route);\n\n  if (!match) {\n    routes.add(route);\n    return routes;\n  }\n\n  const groups = match?.split(',');\n  const groupsSet = new Set(groups);\n\n  if (groupsSet.size !== groups.length) {\n    throw new Error(\n      `Array syntax cannot contain duplicate group name \"${groups}\" in \"${contextKey}\".`\n    );\n  }\n\n  if (groups.length === 1) {\n    routes.add(route);\n    return routes;\n  }\n\n  for (const group of groups) {\n    extrapolateGroupRoutes(route.replace(match, group.trim()), contextKey, routes);\n  }\n\n  return routes;\n}\n\nfunction treeNodeToRouteNode(tree: TreeNode, options: Options): IntermediateRouteNode[] | null {\n  if (tree.node) {\n    return fileNodeToRouteNode(tree, options);\n  }\n\n  return folderNodeToRouteNode(tree, options);\n}\n\nfunction contextModuleToFileNodes(\n  contextModule: RequireContext,\n  options: Options = {},\n  files: string[] = contextModule.keys()\n): FileNode[] {\n  const nodes = files.map((key) => {\n    // In development, check if the file exports a default component\n    // this helps keep things snappy when creating files. In production we load all screens lazily.\n    if (process.env.NODE_ENV === 'development') {\n      // If the user has set the `EXPO_ROUTER_IMPORT_MODE` to `sync` then we should\n      // filter the missing routes.\n      if (EXPO_ROUTER_IMPORT_MODE === 'sync') {\n        const isApi = key.match(/\\+api\\.[jt]sx?$/);\n        if (!isApi && !contextModule(key)?.default) {\n          return null;\n        }\n      }\n    }\n    const node: FileNode = {\n      loadRoute() {\n        if (options.ignoreRequireErrors) {\n          try {\n            return contextModule(key);\n          } catch {\n            return {};\n          }\n        } else {\n          return contextModule(key);\n        }\n      },\n      normalizedName: getNameFromFilePath(key),\n      filePath: key,\n      contextKey: key,\n    };\n\n    return node;\n  });\n\n  return nodes.filter(Boolean) as FileNode[];\n}\n\nfunction hasCustomRootLayoutNode(routes: IntermediateRouteNode[]) {\n  if (routes.length !== 1) {\n    return false;\n  }\n  // This could either be the root _layout or an app with a single file.\n  const route = routes[0];\n\n  if (route.route === '' && route.contextKey.match(/^\\.\\/_layout\\.([jt]sx?)$/)) {\n    return true;\n  }\n  return false;\n}\n\nfunction treeNodesToRootRoute(treeNode: TreeNode, options: Options): IntermediateRouteNode | null {\n  const routes = treeNodeToRouteNode(treeNode, options);\n  return withOptionalRootLayout(routes);\n}\n\nfunction processKeys(files: string[], options: Options): string[] {\n  const { ignore } = options;\n\n  return files.filter((file) => {\n    return !ignore?.some((pattern) => pattern.test(file));\n  });\n}\n\n/**\n * Asserts if the require.context has files that share the same name but have different extensions. Exposed for testing.\n * @private\n */\nexport function assertDuplicateRoutes(filenames: string[]) {\n  if (process.env.NODE_ENV === 'production') {\n    return;\n  }\n\n  const duplicates = filenames\n    .map((filename) => removeSupportedExtensions(filename))\n    .reduce(\n      (acc, filename) => {\n        acc[filename] = acc[filename] ? acc[filename] + 1 : 1;\n        return acc;\n      },\n      {} as Record<string, number>\n    );\n\n  Object.entries(duplicates).forEach(([filename, count]) => {\n    if (count > 1) {\n      throw new Error(`Multiple files match the route name \"${filename}\".`);\n    }\n  });\n}\n\n/** Given a Metro context module, return an array of nested routes. */\nexport function getRoutes(contextModule: RequireContext, options?: Options): RouteNode | null {\n  const route = getExactRoutesInternal(contextModule, options);\n\n  // If there is no route, return an empty route.\n  if (!route) {\n    return null;\n  }\n\n  appendSitemapRoute(route);\n\n  // Auto add not found route if it doesn't exist\n  appendUnmatchedRoute(route);\n\n  if (options?.ignoreEntryPoints) {\n    return removeFilePath(route);\n  }\n  return removeFilePath(crawlAndAppendEntryFilesForInitialRoutes(crawlAndAppendEntryFiles(route)));\n}\n\nfunction removeFilePath(route: IntermediateRouteNode | null): RouteNode | null {\n  if (!route) return route;\n  const { filePath, ...rest } = route;\n\n  return {\n    ...rest,\n    children: route.children.map((child) => removeFilePath(child)).filter(Boolean) as RouteNode[],\n  };\n}\n\nfunction unique<T>(array: T[]): T[] {\n  return [...new Set(array)];\n}\n\nfunction isLayoutRoute(route: IntermediateRouteNode) {\n  return route.contextKey.match(/\\/_layout\\.([jt]sx?)$/);\n}\n\nfunction isViewRoute(route?: IntermediateRouteNode | null): route is IntermediateRouteNode {\n  return !!route && !isApiRoute(route);\n}\nfunction isApiRoute(route: IntermediateRouteNode) {\n  return isApiRoutePath(route.contextKey);\n}\nfunction isApiRoutePath(route: string): boolean {\n  return !!route.match(/\\+api\\.[jt]sx?$/);\n}\n\nfunction crawlAndAppendEntryFiles(\n  route: IntermediateRouteNode | null,\n  entryPoints: string[] = []\n): IntermediateRouteNode | null {\n  if (!isViewRoute(route)) {\n    return null;\n  }\n  const nextEntryPoints = unique([...entryPoints, ...(route.entryPoints ?? []), route.filePath]);\n\n  route.children.forEach((child) => {\n    crawlAndAppendEntryFiles(child, nextEntryPoints);\n  });\n\n  // Skip adding entry points for layout routes since we only need them\n  // for rendering child nodes.\n  if (isLayoutRoute(route)) {\n    delete route.entryPoints;\n  } else {\n    route.entryPoints = nextEntryPoints;\n  }\n\n  return route;\n}\n\nfunction crawlAndAppendEntryFilesForInitialRoutes(\n  route: IntermediateRouteNode | null,\n  initialRoutes: IntermediateRouteNode[] = []\n): IntermediateRouteNode | null {\n  if (!isViewRoute(route)) {\n    return null;\n  }\n\n  // Skip adding entry points for layout routes since we only need them\n  // for rendering child nodes.\n  if (isLayoutRoute(route)) {\n    if (route.initialRouteName) {\n      const initialRoute = route.children.find((child) => child.route === route.initialRouteName);\n      if (!initialRoute) {\n        throw new Error(\n          `Invalid initialRouteName \"${route.initialRouteName}\" defined in ${\n            route.filePath\n          }. Options are: ${route.children.map((route) => route.route).join(', ')}`\n        );\n      }\n      // Update all children to include the entry points from the initial route...\n\n      route.children.forEach((child) => {\n        crawlAndAppendEntryFilesForInitialRoutes(child, [...initialRoutes, initialRoute]);\n      });\n    }\n  } else {\n    const isInitial = initialRoutes.some(\n      (initialRoute) => initialRoute.contextKey === route.contextKey\n    );\n    if (!isInitial) {\n      route.entryPoints = unique([\n        ...initialRoutes.map((route) => route.entryPoints ?? []).flat(),\n        ...(route.entryPoints ?? []),\n      ]);\n    }\n  }\n\n  return route;\n}\n\nfunction getIgnoreList(options?: Options) {\n  const ignore: RegExp[] = [/^\\.\\/\\+html\\.[tj]sx?$/, ...(options?.ignore ?? [])];\n  if (options?.preserveApiRoutes !== true) {\n    ignore.push(/\\+api\\.[tj]sx?$/);\n  }\n  return ignore;\n}\n\nfunction getExactRoutesInternal(\n  contextModule: RequireContext,\n  options: Options = {}\n): IntermediateRouteNode | null {\n  const treeNodes = contextModuleToTree(contextModule, options);\n  return treeNodesToRootRoute(treeNodes, options);\n}\n\n/** Get routes without unmatched or sitemap. */\nexport function getExactRoutes(contextModule: RequireContext, options?: Options): RouteNode | null {\n  const route = getExactRoutesInternal(contextModule, options);\n  if (!options?.ignoreEntryPoints) {\n    return removeFilePath(\n      crawlAndAppendEntryFilesForInitialRoutes(crawlAndAppendEntryFiles(route))\n    );\n  }\n\n  return removeFilePath(route);\n}\n\nfunction contextModuleToTree(contextModule: RequireContext, options?: Options) {\n  const allowed = processKeys(contextModule.keys(), {\n    ...options,\n    ignore: getIgnoreList(options),\n  });\n  assertDuplicateRoutes(allowed);\n  const files = contextModuleToFileNodes(contextModule, options, allowed);\n  return getRecursiveTree(files);\n}\n\nfunction appendSitemapRoute(routes: IntermediateRouteNode) {\n  if (\n    !routes.children.length ||\n    // Allow overriding the sitemap route\n    routes.children.some((route) => route.route === '_sitemap')\n  ) {\n    return routes;\n  }\n  routes.children.push({\n    loadRoute() {\n      const { Sitemap, getNavOptions } = require('./views/Sitemap');\n      return { default: Sitemap, getNavOptions };\n    },\n    filePath: 'expo-router/build/views/Sitemap.js',\n    route: '_sitemap',\n    contextKey: './_sitemap.tsx',\n    generated: true,\n    internal: true,\n    dynamic: null,\n    children: [],\n  });\n  return routes;\n}\n\nfunction appendUnmatchedRoute(routes: IntermediateRouteNode) {\n  // Auto add not found route if it doesn't exist\n  const userDefinedDynamicRoute = getUserDefinedTopLevelNotFoundRoute(routes);\n  if (!userDefinedDynamicRoute) {\n    routes.children.push({\n      loadRoute() {\n        return { default: require('./views/Unmatched').Unmatched };\n      },\n      filePath: 'expo-router/build/views/Unmatched.js',\n      route: '+not-found',\n      contextKey: './+not-found.tsx',\n      dynamic: [{ name: '+not-found', deep: true, notFound: true }],\n      children: [],\n      generated: true,\n      internal: true,\n    });\n  }\n  return routes;\n}\n\n/**\n * Exposed for testing.\n * @returns a top-level deep dynamic route if it exists, otherwise null.\n */\nexport function getUserDefinedTopLevelNotFoundRoute(routes: RouteNode | null): RouteNode | null {\n  // Auto add not found route if it doesn't exist\n  for (const route of routes?.children ?? []) {\n    if (route.generated) continue;\n    const isDeepDynamic =\n      stripGroupSegmentsFromPath(route.route) === '+not-found' && route.route.match(/\\+not-found$/);\n    if (isDeepDynamic) {\n      return route;\n    }\n    // Recurse through group routes\n    if (matchGroupName(route.route)) {\n      const child = getUserDefinedTopLevelNotFoundRoute(route);\n      if (child) {\n        return child;\n      }\n    }\n  }\n  return null;\n}\n\nfunction withOptionalRootLayout(\n  routes: IntermediateRouteNode[] | null\n): IntermediateRouteNode | null {\n  if (!routes?.length) {\n    return null;\n  }\n\n  if (hasCustomRootLayoutNode(routes)) {\n    return routes[0];\n  }\n\n  return {\n    loadRoute: () => ({\n      default: (require('./views/Navigator') as typeof import('./views/Navigator'))\n        .DefaultNavigator,\n    }),\n    filePath: 'expo-router/build/views/Navigator.js',\n    // Generate a fake file name for the directory\n    contextKey: './_layout.tsx',\n    route: '',\n    generated: true,\n    dynamic: null,\n    children: routes,\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}