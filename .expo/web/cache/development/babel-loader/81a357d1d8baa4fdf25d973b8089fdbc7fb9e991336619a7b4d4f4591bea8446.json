{"ast":null,"code":"\"use strict\";\n\nvar _defineProperty = require(\"@babel/runtime/helpers/defineProperty\");\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.stateCache = exports.getLinkingConfig = exports.getNavigationConfig = void 0;\nvar native_1 = require(\"@react-navigation/native\");\nvar getReactNavigationConfig_1 = require(\"./getReactNavigationConfig\");\nvar linking_1 = require(\"./link/linking\");\nfunction getNavigationConfig(routes) {\n  return (0, getReactNavigationConfig_1.getReactNavigationConfig)(routes, true);\n}\nexports.getNavigationConfig = getNavigationConfig;\nfunction getLinkingConfig(routes) {\n  return {\n    prefixes: [],\n    config: getNavigationConfig(routes),\n    getInitialURL: linking_1.getInitialURL,\n    subscribe: linking_1.addEventListener,\n    getStateFromPath: getStateFromPathMemoized,\n    getPathFromState: function getPathFromState(state, options) {\n      var _ref;\n      return (_ref = (0, linking_1.getPathFromState)(state, _objectSpread(_objectSpread({\n        screens: []\n      }, this.config), options))) != null ? _ref : '/';\n    },\n    getActionFromState: native_1.getActionFromState\n  };\n}\nexports.getLinkingConfig = getLinkingConfig;\nexports.stateCache = new Map();\nfunction getStateFromPathMemoized(path, options) {\n  var cached = exports.stateCache.get(path);\n  if (cached) {\n    return cached;\n  }\n  var result = (0, linking_1.getStateFromPath)(path, options);\n  exports.stateCache.set(path, result);\n  return result;\n}","map":{"version":3,"names":["native_1","require","getReactNavigationConfig_1","linking_1","getNavigationConfig","routes","getReactNavigationConfig","exports","getLinkingConfig","prefixes","config","getInitialURL","subscribe","addEventListener","getStateFromPath","getStateFromPathMemoized","getPathFromState","state","options","_ref","_objectSpread","screens","getActionFromState","stateCache","Map","path","cached","get","result","set"],"sources":["/Users/jonathanbruce/Coding/trackr/node_modules/expo-router/src/getLinkingConfig.ts"],"sourcesContent":["import { getActionFromState, LinkingOptions } from '@react-navigation/native';\n\nimport { RouteNode } from './Route';\nimport { State } from './fork/getPathFromState';\nimport { getReactNavigationConfig, Screen } from './getReactNavigationConfig';\nimport {\n  addEventListener,\n  getInitialURL,\n  getPathFromState,\n  getStateFromPath,\n} from './link/linking';\n\nexport function getNavigationConfig(routes: RouteNode): {\n  initialRouteName?: string;\n  screens: Record<string, Screen>;\n} {\n  return getReactNavigationConfig(routes, true);\n}\n\nexport type ExpoLinkingOptions = LinkingOptions<object> & {\n  getPathFromState?: typeof getPathFromState;\n};\n\nexport function getLinkingConfig(routes: RouteNode): ExpoLinkingOptions {\n  return {\n    prefixes: [],\n    // @ts-expect-error\n    config: getNavigationConfig(routes),\n    // A custom getInitialURL is used on native to ensure the app always starts at\n    // the root path if it's launched from something other than a deep link.\n    // This helps keep the native functionality working like the web functionality.\n    // For example, if you had a root navigator where the first screen was `/settings` and the second was `/index`\n    // then `/index` would be used on web and `/settings` would be used on native.\n    getInitialURL,\n    subscribe: addEventListener,\n    getStateFromPath: getStateFromPathMemoized,\n    getPathFromState(state: State, options: Parameters<typeof getPathFromState>[1]) {\n      return (\n        getPathFromState(state, {\n          screens: [],\n          ...this.config,\n          ...options,\n        }) ?? '/'\n      );\n    },\n    // Add all functions to ensure the types never need to fallback.\n    // This is a convenience for usage in the package.\n    getActionFromState,\n  };\n}\n\nexport const stateCache = new Map<string, any>();\n\n/** We can reduce work by memoizing the state by the pathname. This only works because the options (linking config) theoretically never change.  */\nfunction getStateFromPathMemoized(path: string, options: Parameters<typeof getStateFromPath>[1]) {\n  const cached = stateCache.get(path);\n  if (cached) {\n    return cached;\n  }\n  const result = getStateFromPath(path, options);\n  stateCache.set(path, result);\n  return result;\n}\n"],"mappings":";;;;;;;;;AAAA,IAAAA,QAAA,GAAAC,OAAA;AAIA,IAAAC,0BAAA,GAAAD,OAAA;AACA,IAAAE,SAAA,GAAAF,OAAA;AAOA,SAAgBG,mBAAmBA,CAACC,MAAiB;EAInD,OAAO,IAAAH,0BAAA,CAAAI,wBAAwB,EAACD,MAAM,EAAE,IAAI,CAAC;AAC/C;AALAE,OAAA,CAAAH,mBAAA,GAAAA,mBAAA;AAWA,SAAgBI,gBAAgBA,CAACH,MAAiB;EAChD,OAAO;IACLI,QAAQ,EAAE,EAAE;IAEZC,MAAM,EAAEN,mBAAmB,CAACC,MAAM,CAAC;IAMnCM,aAAa,EAAbR,SAAA,CAAAQ,aAAa;IACbC,SAAS,EAAET,SAAA,CAAAU,gBAAgB;IAC3BC,gBAAgB,EAAEC,wBAAwB;IAC1CC,gBAAgB,WAAhBA,gBAAgBA,CAACC,KAAY,EAAEC,OAA+C;MAAA,IAAAC,IAAA;MAC5E,QAAAA,IAAA,GACE,IAAAhB,SAAA,CAAAa,gBAAgB,EAACC,KAAK,EAAAG,aAAA,CAAAA,aAAA;QACpBC,OAAO,EAAE;MAAE,GACR,IAAI,CAACX,MAAM,GACXQ,OAAO,CACX,CAAC,YAAAC,IAAA,GAAI,GAAG;IAEb,CAAC;IAGDG,kBAAkB,EAAlBtB,QAAA,CAAAsB;GACD;AACH;AA1BAf,OAAA,CAAAC,gBAAA,GAAAA,gBAAA;AA4BaD,OAAA,CAAAgB,UAAU,GAAG,IAAIC,GAAG,EAAe;AAGhD,SAAST,wBAAwBA,CAACU,IAAY,EAAEP,OAA+C;EAC7F,IAAMQ,MAAM,GAAGnB,OAAA,CAAAgB,UAAU,CAACI,GAAG,CAACF,IAAI,CAAC;EACnC,IAAIC,MAAM,EAAE;IACV,OAAOA,MAAM;;EAEf,IAAME,MAAM,GAAG,IAAAzB,SAAA,CAAAW,gBAAgB,EAACW,IAAI,EAAEP,OAAO,CAAC;EAC9CX,OAAA,CAAAgB,UAAU,CAACM,GAAG,CAACJ,IAAI,EAAEG,MAAM,CAAC;EAC5B,OAAOA,MAAM;AACf","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}