{"ast":null,"code":"\"use strict\";var _slicedToArray=require(\"@babel/runtime/helpers/slicedToArray\");var _defineProperty=require(\"@babel/runtime/helpers/defineProperty\");var _toConsumableArray=require(\"@babel/runtime/helpers/toConsumableArray\");function ownKeys(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);r&&(o=o.filter(function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable;})),t.push.apply(t,o);}return t;}function _objectSpread(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?ownKeys(Object(t),!0).forEach(function(r){_defineProperty(e,r,t[r]);}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):ownKeys(Object(t)).forEach(function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r));});}return e;}var __importDefault=this&&this.__importDefault||function(mod){return mod&&mod.__esModule?mod:{\"default\":mod};};Object.defineProperty(exports,\"__esModule\",{value:true});exports.stripBaseUrl=exports.getMatchableRouteConfigs=exports.getUrlWithReactNavigationConcessions=void 0;var escape_string_regexp_1=__importDefault(require(\"escape-string-regexp\"));var findFocusedRoute_1=require(\"./findFocusedRoute\");var validatePathConfig_1=__importDefault(require(\"./validatePathConfig\"));var matchers_1=require(\"../matchers\");function getUrlWithReactNavigationConcessions(path){var baseUrl=arguments.length>1&&arguments[1]!==undefined?arguments[1]:\"\";var parsed;try{parsed=new URL(path,'https://phony.example');}catch(_unused){return{nonstandardPathname:'',inputPathnameWithoutHash:''};}var pathname=parsed.pathname;return{nonstandardPathname:stripBaseUrl(pathname,baseUrl).replace(/^\\/+/g,'').replace(/\\/+$/g,'')+'/',inputPathnameWithoutHash:stripBaseUrl(path,baseUrl).replace(/#.*$/,'')};}exports.getUrlWithReactNavigationConcessions=getUrlWithReactNavigationConcessions;function getStateFromPath(path,options){var _getMatchableRouteCon=getMatchableRouteConfigs(options),initialRoutes=_getMatchableRouteCon.initialRoutes,configs=_getMatchableRouteCon.configs;return getStateFromPathWithConfigs(path,configs,initialRoutes);}exports.default=getStateFromPath;function getMatchableRouteConfigs(options){if(options){(0,validatePathConfig_1.default)(options);}var screens=options==null?void 0:options.screens;if(!screens){throw Error(\"You must pass a 'screens' object to 'getStateFromPath' to generate a path.\");}var initialRoutes=[];if(options!=null&&options.initialRouteName){initialRoutes.push({initialRouteName:options.initialRouteName,parentScreens:[]});}var converted=Object.keys(screens).map(function(key){return _createNormalizedConfigs(key,screens,[],initialRoutes);}).flat();var resolvedInitialPatterns=initialRoutes.map(function(route){return joinPaths.apply(void 0,_toConsumableArray(route.parentScreens).concat([route.initialRouteName]));});var convertedWithInitial=converted.map(function(config){return _objectSpread(_objectSpread({},config),{},{isInitial:resolvedInitialPatterns.includes(config.routeNames.join('/'))});});var configs=convertedWithInitial.sort(sortConfigs);assertConfigDuplicates(configs);return{configs:configs,initialRoutes:initialRoutes};}exports.getMatchableRouteConfigs=getMatchableRouteConfigs;function assertConfigDuplicates(configs){configs.reduce(function(acc,config){var _config$regex$toStrin,_config$regex;var indexedKey=(_config$regex$toStrin=(_config$regex=config.regex)==null?void 0:_config$regex.toString())!=null?_config$regex$toStrin:config.pattern;var alpha=acc[indexedKey];if(alpha&&!alpha.hasChildren&&!config.hasChildren){var a=alpha.routeNames;var b=config.routeNames;var intersects=a.length>b.length?b.every(function(it,i){return a[i]===it;}):a.every(function(it,i){return b[i]===it;});if(!intersects){var last=config.pattern.split('/').pop();if(!(last!=null&&last.match(/^\\*not-found$/))){var routeType=last!=null&&last.startsWith(':')?'dynamic route':last!=null&&last.startsWith('*')?'dynamic-rest route':'route';throw new Error(`The ${routeType} pattern '${config.pattern||'/'}' resolves to both '${alpha.userReadableName}' and '${config.userReadableName}'. Patterns must be unique and cannot resolve to more than one route.`);}}}return Object.assign(acc,_defineProperty({},indexedKey,config));},{});}function sortConfigs(a,b){if(a.pattern===b.pattern){return b.routeNames.join('>').localeCompare(a.routeNames.join('>'));}if(a.pattern.startsWith(b.pattern)&&b.screen!=='index'){return-1;}if(b.pattern.startsWith(a.pattern)&&a.screen!=='index'){return 1;}var aParts=a.pattern.split('/').filter(function(part){return(0,matchers_1.matchGroupName)(part)==null;});if(a.screen==='index'){aParts.push('index');}var bParts=b.pattern.split('/').filter(function(part){return(0,matchers_1.matchGroupName)(part)==null;});if(b.screen==='index'){bParts.push('index');}for(var i=0;i<Math.max(aParts.length,bParts.length);i++){if(aParts[i]==null){return 1;}if(bParts[i]==null){return-1;}var aWildCard=aParts[i].startsWith('*');var bWildCard=bParts[i].startsWith('*');if(aWildCard&&bWildCard){var aNotFound=aParts[i].match(/^[*]not-found$/);var bNotFound=bParts[i].match(/^[*]not-found$/);if(aNotFound&&bNotFound){continue;}else if(aNotFound){return 1;}else if(bNotFound){return-1;}continue;}if(aWildCard){return 1;}if(bWildCard){return-1;}var aSlug=aParts[i].startsWith(':');var bSlug=bParts[i].startsWith(':');if(aSlug&&bSlug){var _aNotFound=aParts[i].match(/^[*]not-found$/);var _bNotFound=bParts[i].match(/^[*]not-found$/);if(_aNotFound&&_bNotFound){continue;}else if(_aNotFound){return 1;}else if(_bNotFound){return-1;}continue;}if(aSlug){return 1;}if(bSlug){return-1;}}if(a.isInitial&&!b.isInitial){return-1;}if(!a.isInitial&&b.isInitial){return 1;}return bParts.length-aParts.length;}function getStateFromEmptyPathWithConfigs(path,configs,initialRoutes){var _ref,_leafNodes$find;var leafNodes=configs.filter(function(config){return!config.hasChildren;}).map(function(value){return _objectSpread(_objectSpread({},value),{},{path:(0,matchers_1.stripGroupSegmentsFromPath)(value.path)});});var match=(_ref=(_leafNodes$find=leafNodes.find(function(config){return(config.path===''&&(!config.regex||config.regex.test('')));}))!=null?_leafNodes$find:leafNodes.find(function(config){return(config.path.startsWith(':')&&config.regex.test(''));}))!=null?_ref:leafNodes.find(function(config){return config.path.startsWith('*')&&config.regex.test('/');});if(!match){return undefined;}var routes=match.routeNames.map(function(name){if(!match._route){return{name:name};}return{name:name,_route:match._route};});return createNestedStateObject(path,routes,configs,initialRoutes);}function getStateFromPathWithConfigs(path,configs,initialRoutes){var formattedPaths=getUrlWithReactNavigationConcessions(path);if(formattedPaths.nonstandardPathname==='/'){return getStateFromEmptyPathWithConfigs(formattedPaths.inputPathnameWithoutHash,configs,initialRoutes);}var routes=matchAgainstConfigs(formattedPaths.nonstandardPathname,configs);if(routes==null){return undefined;}return createNestedStateObject(formattedPaths.inputPathnameWithoutHash,routes,configs,initialRoutes);}var joinPaths=function joinPaths(){var _ref2;for(var _len=arguments.length,paths=new Array(_len),_key=0;_key<_len;_key++){paths[_key]=arguments[_key];}return(_ref2=[]).concat.apply(_ref2,_toConsumableArray(paths.map(function(p){return p.split('/');}))).filter(Boolean).join('/');};function matchAgainstConfigs(remaining,configs){var routes;var remainingPath=remaining;var _loop=function _loop(config){var _config$pattern;if(!config.regex){return 0;}var match=remainingPath.match(config.regex);if(!match){return 0;}var matchedParams=(_config$pattern=config.pattern)==null?void 0:_config$pattern.split('/').filter(function(p){return p.match(/^[:*]/);}).reduce(function(acc,p,i){var _match;if(p.match(/^\\*/)){return _objectSpread(_objectSpread({},acc),{},_defineProperty({},p,match[(i+1)*2]));}return Object.assign(acc,_defineProperty({},p,(_match=match[(i+1)*2])==null?void 0:_match.replace(/\\//,'')));},{});var routeFromName=function routeFromName(name){var config=configs.find(function(c){return c.screen===name;});if(!(config!=null&&config.path)){return{name:name};}var segments=config.path.split('/');var params={};segments.filter(function(p){return p.match(/^[:*]/);}).forEach(function(p){var value=matchedParams[p];if(value){var _config$parse;if(p.match(/^\\*/)){var _value;value=(_value=value)==null?void 0:_value.split('/').filter(Boolean);}var key=p.replace(/^[:*]/,'').replace(/\\?$/,'');params[key]=(_config$parse=config.parse)!=null&&_config$parse[key]?config.parse[key](value):value;}});if(params&&Object.keys(params).length){return{name:name,params:params};}return{name:name};};routes=config.routeNames.map(function(name){if(!config._route){return _objectSpread({},routeFromName(name));}return _objectSpread(_objectSpread({},routeFromName(name)),{},{_route:config._route});});var combinedParams=routes.reduce(function(acc,r){return Object.assign(acc,r.params);},{});var hasCombinedParams=Object.keys(combinedParams).length>0;routes=routes.map(function(r){if(hasCombinedParams){r.params=combinedParams;}return r;});remainingPath=remainingPath.replace(match[1],'');return 1;},_ret;for(var config of configs){_ret=_loop(config);if(_ret===0)continue;if(_ret===1)break;}return routes;}function equalHeritage(a,b){if(a.length!==b.length){return false;}for(var i=0;i<a.length;i++){if(a[i].localeCompare(b[i])!==0){return false;}}return true;}var _createNormalizedConfigs=function createNormalizedConfigs(screen,routeConfig){var routeNames=arguments.length>2&&arguments[2]!==undefined?arguments[2]:[];var initials=arguments.length>3&&arguments[3]!==undefined?arguments[3]:[];var parentScreens=arguments.length>4&&arguments[4]!==undefined?arguments[4]:[];var parentPattern=arguments.length>5?arguments[5]:undefined;var configs=[];routeNames.push(screen);parentScreens.push(screen);var config=routeConfig[screen];if(typeof config==='string'){var pattern=parentPattern?joinPaths(parentPattern,config):config;configs.push(createConfigItem(screen,routeNames,pattern,config,false));}else if(typeof config==='object'){var _pattern;var _route=config._route;if(typeof config.path==='string'){var _Object$keys;if(config.exact&&config.path===undefined){throw new Error(\"A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. `path: ''`.\");}_pattern=config.exact!==true?joinPaths(parentPattern||'',config.path||''):config.path||'';configs.push(createConfigItem(screen,routeNames,_pattern,config.path,config.screens?!!((_Object$keys=Object.keys(config.screens))!=null&&_Object$keys.length):false,config.parse,_route));}if(config.screens){if(config.initialRouteName){initials.push({initialRouteName:config.initialRouteName,parentScreens:parentScreens});}Object.keys(config.screens).forEach(function(nestedConfig){var _pattern2;var result=_createNormalizedConfigs(nestedConfig,config.screens,routeNames,initials,_toConsumableArray(parentScreens),(_pattern2=_pattern)!=null?_pattern2:parentPattern);configs.push.apply(configs,_toConsumableArray(result));});}}routeNames.pop();return configs;};function formatRegexPattern(it){it=it.replace(' ','%20');if(it.startsWith(':')){return`(([^/]+\\\\/)${it.endsWith('?')?'?':''})`;}else if(it.startsWith('*')){return`((.*\\\\/)${it.endsWith('?')?'?':''})`;}if((0,matchers_1.matchGroupName)(it)!=null){return`(?:${(0,escape_string_regexp_1.default)(it)}\\\\/)?`;}return(0,escape_string_regexp_1.default)(it)+`\\\\/`;}var createConfigItem=function createConfigItem(screen,routeNames,pattern,path,hasChildren,parse,_route){pattern=pattern.split('/').filter(Boolean).join('/');var regex=pattern?new RegExp(`^(${pattern.split('/').map(formatRegexPattern).join('')})$`):undefined;return{screen:screen,regex:regex,pattern:pattern,path:path,routeNames:_toConsumableArray(routeNames),parse:parse,userReadableName:[].concat(_toConsumableArray(routeNames.slice(0,-1)),[path||screen]).join('/'),hasChildren:!!hasChildren,_route:_route};};var findParseConfigForRoute=function findParseConfigForRoute(routeName,routeConfigs){for(var config of routeConfigs){if(routeName===config.routeNames[config.routeNames.length-1]){return config.parse;}}return undefined;};var findInitialRoute=function findInitialRoute(routeName,parentScreens,initialRoutes){for(var config of initialRoutes){if(equalHeritage(parentScreens,config.parentScreens)){return routeName!==config.initialRouteName?config.initialRouteName:undefined;}}return undefined;};var createStateObject=function createStateObject(initialRoute,route,isEmpty){if(isEmpty){if(initialRoute){return{index:1,routes:[{name:initialRoute},route]};}return{routes:[route]};}if(initialRoute){return{index:1,routes:[{name:initialRoute},_objectSpread(_objectSpread({},route),{},{state:{routes:[]}})]};}return{routes:[_objectSpread(_objectSpread({},route),{},{state:{routes:[]}})]};};var createNestedStateObject=function createNestedStateObject(path,routes,routeConfigs,initialRoutes){var route=routes.shift();var parentScreens=[];var initialRoute=findInitialRoute(route.name,parentScreens,initialRoutes);parentScreens.push(route.name);var state=createStateObject(initialRoute,route,routes.length===0);if(routes.length>0){var nestedState=state;while(route=routes.shift()){initialRoute=findInitialRoute(route.name,parentScreens,initialRoutes);var nestedStateIndex=nestedState.index||nestedState.routes.length-1;nestedState.routes[nestedStateIndex].state=createStateObject(initialRoute,route,routes.length===0);if(routes.length>0){nestedState=nestedState.routes[nestedStateIndex].state;}parentScreens.push(route.name);}}route=(0,findFocusedRoute_1.findFocusedRoute)(state);route.path=(0,matchers_1.stripGroupSegmentsFromPath)(path);var params=parseQueryParams(route.path,findParseConfigForRoute(route.name,routeConfigs));if(params){route.params=Object.assign(Object.create(null),route.params);for(var _ref3 of Object.entries(params)){var _route$params,_route$params2;var _ref4=_slicedToArray(_ref3,2);var name=_ref4[0];var value=_ref4[1];if((_route$params=route.params)!=null&&_route$params[name]){if(\"production\"!=='production'){console.warn(`Route '/${route.name}' with param '${name}' was specified both in the path and as a param, removing from path`);}}if(!((_route$params2=route.params)!=null&&_route$params2[name])){route.params[name]=value;continue;}}if(Object.keys(route.params).length===0){delete route.params;}}return state;};var parseQueryParams=function parseQueryParams(path,parseConfig){var query=path.split('?')[1];var searchParams=new URLSearchParams(query);var params=Object.fromEntries(searchParams);if(parseConfig){Object.keys(params).forEach(function(name){if(Object.hasOwnProperty.call(parseConfig,name)&&typeof params[name]==='string'){params[name]=parseConfig[name](params[name]);}});}return Object.keys(params).length?params:undefined;};var baseUrlCache=new Map();function getBaseUrlRegex(baseUrl){if(baseUrlCache.has(baseUrl)){return baseUrlCache.get(baseUrl);}var regex=new RegExp(`^\\\\/?${(0,escape_string_regexp_1.default)(baseUrl)}`,'g');baseUrlCache.set(baseUrl,regex);return regex;}function stripBaseUrl(path){var baseUrl=arguments.length>1&&arguments[1]!==undefined?arguments[1]:\"\";if(\"production\"!=='development'){if(baseUrl){var reg=getBaseUrlRegex(baseUrl);return path.replace(/^\\/+/g,'/').replace(reg,'');}}return path;}exports.stripBaseUrl=stripBaseUrl;","map":{"version":3,"names":["escape_string_regexp_1","__importDefault","require","findFocusedRoute_1","validatePathConfig_1","matchers_1","getUrlWithReactNavigationConcessions","path","baseUrl","arguments","length","undefined","parsed","URL","_unused","nonstandardPathname","inputPathnameWithoutHash","pathname","stripBaseUrl","replace","exports","getStateFromPath","options","_getMatchableRouteCon","getMatchableRouteConfigs","initialRoutes","configs","getStateFromPathWithConfigs","default","screens","Error","initialRouteName","push","parentScreens","converted","Object","keys","map","key","createNormalizedConfigs","flat","resolvedInitialPatterns","route","joinPaths","apply","_toConsumableArray","concat","convertedWithInitial","config","_objectSpread","isInitial","includes","routeNames","join","sort","sortConfigs","assertConfigDuplicates","reduce","acc","_config$regex$toStrin","_config$regex","indexedKey","regex","toString","pattern","alpha","hasChildren","a","b","intersects","every","it","i","last","split","pop","match","routeType","startsWith","userReadableName","assign","_defineProperty","localeCompare","screen","aParts","filter","part","matchGroupName","bParts","Math","max","aWildCard","bWildCard","aNotFound","bNotFound","aSlug","bSlug","getStateFromEmptyPathWithConfigs","_ref","_leafNodes$find","leafNodes","value","stripGroupSegmentsFromPath","find","test","routes","name","_route","createNestedStateObject","formattedPaths","matchAgainstConfigs","_ref2","_len","paths","Array","_key","p","Boolean","remaining","remainingPath","_loop","_config$pattern","matchedParams","_match","routeFromName","c","segments","params","forEach","_config$parse","_value","parse","combinedParams","r","hasCombinedParams","_ret","equalHeritage","routeConfig","initials","parentPattern","createConfigItem","_Object$keys","exact","nestedConfig","_pattern2","result","formatRegexPattern","endsWith","RegExp","slice","findParseConfigForRoute","routeName","routeConfigs","findInitialRoute","createStateObject","initialRoute","isEmpty","index","state","shift","nestedState","nestedStateIndex","findFocusedRoute","parseQueryParams","create","_ref3","entries","_route$params","_route$params2","_ref4","_slicedToArray","console","warn","parseConfig","query","searchParams","URLSearchParams","fromEntries","hasOwnProperty","call","baseUrlCache","Map","getBaseUrlRegex","has","get","set","reg"],"sources":["/Users/jonathanbruce/Coding/trackr/node_modules/expo-router/src/fork/getStateFromPath.ts"],"sourcesContent":["import { PathConfigMap } from '@react-navigation/core';\nimport type { InitialState, NavigationState, PartialState } from '@react-navigation/routers';\nimport escape from 'escape-string-regexp';\n\nimport { findFocusedRoute } from './findFocusedRoute';\nimport validatePathConfig from './validatePathConfig';\nimport { RouteNode } from '../Route';\nimport { matchGroupName, stripGroupSegmentsFromPath } from '../matchers';\n\ntype Options<ParamList extends object> = {\n  initialRouteName?: string;\n  screens: PathConfigMap<ParamList>;\n};\n\ntype ParseConfig = Record<string, (value: string) => any>;\n\ntype RouteConfig = {\n  isInitial?: boolean;\n  screen: string;\n  regex?: RegExp;\n  path: string;\n  pattern: string;\n  routeNames: string[];\n  parse?: ParseConfig;\n  hasChildren: boolean;\n  userReadableName: string;\n  _route?: RouteNode;\n};\n\ntype InitialRouteConfig = {\n  initialRouteName: string;\n  parentScreens: string[];\n};\n\nexport type ResultState = PartialState<NavigationState> & {\n  state?: ResultState;\n};\n\ntype ParsedRoute = {\n  name: string;\n  path?: string;\n  params?: Record<string, any> | undefined;\n};\n\nexport function getUrlWithReactNavigationConcessions(\n  path: string,\n  baseUrl: string | undefined = process.env.EXPO_BASE_URL\n) {\n  let parsed: URL;\n  try {\n    parsed = new URL(path, 'https://phony.example');\n  } catch {\n    // Do nothing with invalid URLs.\n    return {\n      nonstandardPathname: '',\n      inputPathnameWithoutHash: '',\n    };\n  }\n\n  const pathname = parsed.pathname;\n\n  // Make sure there is a trailing slash\n  return {\n    // The slashes are at the end, not the beginning\n    nonstandardPathname:\n      stripBaseUrl(pathname, baseUrl).replace(/^\\/+/g, '').replace(/\\/+$/g, '') + '/',\n\n    // React Navigation doesn't support hashes, so here\n    inputPathnameWithoutHash: stripBaseUrl(path, baseUrl).replace(/#.*$/, ''),\n  };\n}\n\n/**\n * Utility to parse a path string to initial state object accepted by the container.\n * This is useful for deep linking when we need to handle the incoming URL.\n *\n * @example\n * ```js\n * getStateFromPath(\n *   '/chat/jane/42',\n *   {\n *     screens: {\n *       Chat: {\n *         path: 'chat/:author/:id',\n *         parse: { id: Number }\n *       }\n *     }\n *   }\n * )\n * ```\n * @param path Path string to parse and convert, e.g. /foo/bar?count=42.\n * @param options Extra options to fine-tune how to parse the path.\n */\nexport default function getStateFromPath<ParamList extends object>(\n  path: string,\n  options?: Options<ParamList>\n): ResultState | undefined {\n  const { initialRoutes, configs } = getMatchableRouteConfigs(options);\n\n  return getStateFromPathWithConfigs(path, configs, initialRoutes);\n}\n\nexport function getMatchableRouteConfigs<ParamList extends object>(options?: Options<ParamList>) {\n  if (options) {\n    validatePathConfig(options);\n  }\n\n  const screens = options?.screens;\n  // Expo Router disallows usage without a linking config.\n  if (!screens) {\n    throw Error(\"You must pass a 'screens' object to 'getStateFromPath' to generate a path.\");\n  }\n\n  // This will be mutated...\n  const initialRoutes: InitialRouteConfig[] = [];\n\n  if (options?.initialRouteName) {\n    initialRoutes.push({\n      initialRouteName: options.initialRouteName,\n      parentScreens: [],\n    });\n  }\n\n  // Create a normalized configs array which will be easier to use.\n  const converted = Object.keys(screens)\n    .map((key) => createNormalizedConfigs(key, screens, [], initialRoutes))\n    .flat();\n\n  const resolvedInitialPatterns = initialRoutes.map((route) =>\n    joinPaths(...route.parentScreens, route.initialRouteName)\n  );\n\n  const convertedWithInitial = converted.map((config) => ({\n    ...config,\n    // TODO(EvanBacon): Probably a safer way to do this\n    // Mark initial routes to give them potential priority over other routes that match.\n    isInitial: resolvedInitialPatterns.includes(config.routeNames.join('/')),\n  }));\n\n  // Sort in order of resolution. This is extremely important for the algorithm to work.\n  const configs = convertedWithInitial.sort(sortConfigs);\n\n  // Assert any duplicates before we start parsing.\n  assertConfigDuplicates(configs);\n\n  return { configs, initialRoutes };\n}\n\nfunction assertConfigDuplicates(configs: RouteConfig[]) {\n  // Check for duplicate patterns in the config\n  configs.reduce<Record<string, RouteConfig>>((acc, config) => {\n    // NOTE(EvanBacon): Uses the regex pattern as key to detect duplicate slugs.\n    const indexedKey = config.regex?.toString() ?? config.pattern;\n    const alpha = acc[indexedKey];\n    // NOTE(EvanBacon): Skips checking nodes that have children.\n    if (alpha && !alpha.hasChildren && !config.hasChildren) {\n      const a = alpha.routeNames;\n      const b = config.routeNames;\n\n      // It's not a problem if the path string omitted from a inner most screen\n      // For example, it's ok if a path resolves to `A > B > C` or `A > B`\n      const intersects =\n        a.length > b.length ? b.every((it, i) => a[i] === it) : a.every((it, i) => b[i] === it);\n\n      if (!intersects) {\n        // NOTE(EvanBacon): Adds more context to the error message since we know about the\n        // file-based routing.\n        const last = config.pattern.split('/').pop();\n\n        if (!last?.match(/^\\*not-found$/)) {\n          const routeType = last?.startsWith(':')\n            ? 'dynamic route'\n            : last?.startsWith('*')\n            ? 'dynamic-rest route'\n            : 'route';\n          throw new Error(\n            `The ${routeType} pattern '${config.pattern || '/'}' resolves to both '${\n              alpha.userReadableName\n            }' and '${\n              config.userReadableName\n            }'. Patterns must be unique and cannot resolve to more than one route.`\n          );\n        }\n      }\n    }\n\n    return Object.assign(acc, {\n      [indexedKey]: config,\n    });\n  }, {});\n}\n\nfunction sortConfigs(a: RouteConfig, b: RouteConfig): number {\n  // Sort config so that:\n  // - the most exhaustive ones are always at the beginning\n  // - patterns with wildcard are always at the end\n\n  // If 2 patterns are same, move the one with less route names up\n  // This is an error state, so it's only useful for consistent error messages\n  if (a.pattern === b.pattern) {\n    return b.routeNames.join('>').localeCompare(a.routeNames.join('>'));\n  }\n\n  // If one of the patterns starts with the other, it's more exhaustive\n  // So move it up\n  if (\n    a.pattern.startsWith(b.pattern) &&\n    // NOTE(EvanBacon): This is a hack to make sure that `*` is always at the end\n    b.screen !== 'index'\n  ) {\n    return -1;\n  }\n\n  if (b.pattern.startsWith(a.pattern) && a.screen !== 'index') {\n    return 1;\n  }\n\n  // NOTE(EvanBacon): Here we append `index` if the screen was `index` so the length is the same\n  // as a slug or wildcard when nested more than one level deep.\n  // This is so we can compare the length of the pattern, e.g. `foo/*` > `foo` vs `*` < ``.\n  const aParts = a.pattern\n    .split('/')\n    // Strip out group names to ensure they don't affect the priority.\n    .filter((part) => matchGroupName(part) == null);\n  if (a.screen === 'index') {\n    aParts.push('index');\n  }\n\n  const bParts = b.pattern.split('/').filter((part) => matchGroupName(part) == null);\n  if (b.screen === 'index') {\n    bParts.push('index');\n  }\n\n  for (let i = 0; i < Math.max(aParts.length, bParts.length); i++) {\n    // if b is longer, b get higher priority\n    if (aParts[i] == null) {\n      return 1;\n    }\n    // if a is longer, a get higher priority\n    if (bParts[i] == null) {\n      return -1;\n    }\n\n    const aWildCard = aParts[i].startsWith('*');\n    const bWildCard = bParts[i].startsWith('*');\n    // if both are wildcard we compare next component\n    if (aWildCard && bWildCard) {\n      const aNotFound = aParts[i].match(/^[*]not-found$/);\n      const bNotFound = bParts[i].match(/^[*]not-found$/);\n\n      if (aNotFound && bNotFound) {\n        continue;\n      } else if (aNotFound) {\n        return 1;\n      } else if (bNotFound) {\n        return -1;\n      }\n      continue;\n    }\n    // if only a is wild card, b get higher priority\n    if (aWildCard) {\n      return 1;\n    }\n    // if only b is wild card, a get higher priority\n    if (bWildCard) {\n      return -1;\n    }\n\n    const aSlug = aParts[i].startsWith(':');\n    const bSlug = bParts[i].startsWith(':');\n    // if both are wildcard we compare next component\n    if (aSlug && bSlug) {\n      const aNotFound = aParts[i].match(/^[*]not-found$/);\n      const bNotFound = bParts[i].match(/^[*]not-found$/);\n\n      if (aNotFound && bNotFound) {\n        continue;\n      } else if (aNotFound) {\n        return 1;\n      } else if (bNotFound) {\n        return -1;\n      }\n\n      continue;\n    }\n    // if only a is wild card, b get higher priority\n    if (aSlug) {\n      return 1;\n    }\n    // if only b is wild card, a get higher priority\n    if (bSlug) {\n      return -1;\n    }\n  }\n\n  // Sort initial routes with a higher priority than routes which will push more screens\n  // this ensures shared routes go to the shortest path.\n  if (a.isInitial && !b.isInitial) {\n    return -1;\n  }\n  if (!a.isInitial && b.isInitial) {\n    return 1;\n  }\n\n  return bParts.length - aParts.length;\n}\n\nfunction getStateFromEmptyPathWithConfigs(\n  path: string,\n  configs: RouteConfig[],\n  initialRoutes: InitialRouteConfig[]\n): ResultState | undefined {\n  // We need to add special handling of empty path so navigation to empty path also works\n  // When handling empty path, we should only look at the root level config\n\n  // NOTE(EvanBacon): We only care about matching leaf nodes.\n  const leafNodes = configs\n    .filter((config) => !config.hasChildren)\n    .map((value) => {\n      return {\n        ...value,\n        // Collapse all levels of group segments before testing.\n        // This enables `app/(one)/(two)/index.js` to be matched.\n        path: stripGroupSegmentsFromPath(value.path),\n      };\n    });\n\n  const match =\n    leafNodes.find(\n      (config) =>\n        // NOTE(EvanBacon): Test leaf node index routes that either don't have a regex or match an empty string.\n        config.path === '' && (!config.regex || config.regex.test(''))\n    ) ??\n    leafNodes.find(\n      (config) =>\n        // NOTE(EvanBacon): Test leaf node dynamic routes that match an empty string.\n        config.path.startsWith(':') && config.regex!.test('')\n    ) ??\n    // NOTE(EvanBacon): Test leaf node deep dynamic routes that match a slash.\n    // This should be done last to enable dynamic routes having a higher priority.\n    leafNodes.find((config) => config.path.startsWith('*') && config.regex!.test('/'));\n\n  if (!match) {\n    return undefined;\n  }\n\n  const routes = match.routeNames.map((name) => {\n    if (!match._route) {\n      return { name };\n    }\n    return {\n      name,\n      _route: match._route,\n    };\n  });\n\n  return createNestedStateObject(path, routes, configs, initialRoutes);\n}\n\nfunction getStateFromPathWithConfigs(\n  path: string,\n  configs: RouteConfig[],\n  initialRoutes: InitialRouteConfig[]\n): ResultState | undefined {\n  const formattedPaths = getUrlWithReactNavigationConcessions(path);\n\n  if (formattedPaths.nonstandardPathname === '/') {\n    return getStateFromEmptyPathWithConfigs(\n      formattedPaths.inputPathnameWithoutHash,\n      configs,\n      initialRoutes\n    );\n  }\n\n  // We match the whole path against the regex instead of segments\n  // This makes sure matches such as wildcard will catch any unmatched routes, even if nested\n  const routes = matchAgainstConfigs(formattedPaths.nonstandardPathname, configs);\n\n  if (routes == null) {\n    return undefined;\n  }\n  // This will always be empty if full path matched\n  return createNestedStateObject(\n    formattedPaths.inputPathnameWithoutHash,\n    routes,\n    configs,\n    initialRoutes\n  );\n}\n\nconst joinPaths = (...paths: string[]): string =>\n  ([] as string[])\n    .concat(...paths.map((p) => p.split('/')))\n    .filter(Boolean)\n    .join('/');\n\nfunction matchAgainstConfigs(remaining: string, configs: RouteConfig[]): ParsedRoute[] | undefined {\n  let routes: ParsedRoute[] | undefined;\n  let remainingPath = remaining;\n\n  // Go through all configs, and see if the next path segment matches our regex\n  for (const config of configs) {\n    if (!config.regex) {\n      continue;\n    }\n\n    const match = remainingPath.match(config.regex);\n\n    // If our regex matches, we need to extract params from the path\n    if (!match) {\n      continue;\n    }\n\n    // TODO: Add support for wildcard routes\n    const matchedParams = config.pattern\n      ?.split('/')\n      .filter((p) => p.match(/^[:*]/))\n      .reduce<Record<string, any>>((acc, p, i) => {\n        if (p.match(/^\\*/)) {\n          return {\n            ...acc,\n            [p]: match![(i + 1) * 2], //?.replace(/\\//, \"\"),\n          };\n        }\n        return Object.assign(acc, {\n          // The param segments appear every second item starting from 2 in the regex match result.\n          // This will only work if we ensure groups aren't included in the match.\n          [p]: match![(i + 1) * 2]?.replace(/\\//, ''),\n        });\n      }, {});\n\n    const routeFromName = (name: string) => {\n      const config = configs.find((c) => c.screen === name);\n      if (!config?.path) {\n        return { name };\n      }\n\n      const segments = config.path.split('/');\n\n      const params: Record<string, any> = {};\n\n      segments\n        .filter((p) => p.match(/^[:*]/))\n        .forEach((p) => {\n          let value = matchedParams[p];\n          if (value) {\n            if (p.match(/^\\*/)) {\n              // Convert to an array before providing as a route.\n              value = value?.split('/').filter(Boolean);\n            }\n\n            const key = p.replace(/^[:*]/, '').replace(/\\?$/, '');\n            params[key] = config.parse?.[key] ? config.parse[key](value) : value;\n          }\n        });\n\n      if (params && Object.keys(params).length) {\n        return { name, params };\n      }\n\n      return { name };\n    };\n\n    routes = config.routeNames.map((name) => {\n      if (!config._route) {\n        return { ...routeFromName(name) };\n      }\n      return {\n        ...routeFromName(name),\n        _route: config._route,\n      };\n    });\n\n    // TODO(EvanBacon): Maybe we should warn / assert if multiple slugs use the same param name.\n    const combinedParams = routes.reduce<Record<string, any>>(\n      (acc, r) => Object.assign(acc, r.params),\n      {}\n    );\n\n    const hasCombinedParams = Object.keys(combinedParams).length > 0;\n\n    // Combine all params so a route `[foo]/[bar]/other.js` has access to `{ foo, bar }`\n    routes = routes.map((r) => {\n      if (hasCombinedParams) {\n        r.params = combinedParams;\n      }\n      return r;\n    });\n\n    remainingPath = remainingPath.replace(match[1], '');\n\n    break;\n  }\n\n  return routes;\n}\n\nfunction equalHeritage(a: string[], b: string[]): boolean {\n  if (a.length !== b.length) {\n    return false;\n  }\n  for (let i = 0; i < a.length; i++) {\n    if (a[i].localeCompare(b[i]) !== 0) {\n      return false;\n    }\n  }\n  return true;\n}\n\nconst createNormalizedConfigs = (\n  screen: string,\n  routeConfig: PathConfigMap<object>,\n  routeNames: string[] = [],\n  initials: InitialRouteConfig[] = [],\n  parentScreens: string[] = [],\n  parentPattern?: string\n): RouteConfig[] => {\n  const configs: RouteConfig[] = [];\n\n  routeNames.push(screen);\n\n  parentScreens.push(screen);\n\n  const config = (routeConfig as any)[screen];\n\n  if (typeof config === 'string') {\n    // TODO: This should never happen with the addition of `_route`\n\n    // If a string is specified as the value of the key(e.g. Foo: '/path'), use it as the pattern\n    const pattern = parentPattern ? joinPaths(parentPattern, config) : config;\n\n    configs.push(createConfigItem(screen, routeNames, pattern, config, false));\n  } else if (typeof config === 'object') {\n    let pattern: string | undefined;\n\n    const { _route } = config;\n    // if an object is specified as the value (e.g. Foo: { ... }),\n    // it can have `path` property and\n    // it could have `screens` prop which has nested configs\n    if (typeof config.path === 'string') {\n      if (config.exact && config.path === undefined) {\n        throw new Error(\n          \"A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. `path: ''`.\"\n        );\n      }\n\n      pattern =\n        config.exact !== true\n          ? joinPaths(parentPattern || '', config.path || '')\n          : config.path || '';\n\n      configs.push(\n        createConfigItem(\n          screen,\n          routeNames,\n          pattern!,\n          config.path,\n          config.screens ? !!Object.keys(config.screens)?.length : false,\n          config.parse,\n          _route\n        )\n      );\n    }\n\n    if (config.screens) {\n      // property `initialRouteName` without `screens` has no purpose\n      if (config.initialRouteName) {\n        initials.push({\n          initialRouteName: config.initialRouteName,\n          parentScreens,\n        });\n      }\n\n      Object.keys(config.screens).forEach((nestedConfig) => {\n        const result = createNormalizedConfigs(\n          nestedConfig,\n          config.screens as PathConfigMap<object>,\n          routeNames,\n          initials,\n          [...parentScreens],\n          pattern ?? parentPattern\n        );\n\n        configs.push(...result);\n      });\n    }\n  }\n\n  routeNames.pop();\n\n  return configs;\n};\n\nfunction formatRegexPattern(it: string): string {\n  // Allow spaces in file path names.\n  it = it.replace(' ', '%20');\n\n  if (it.startsWith(':')) {\n    // TODO: Remove unused match group\n    return `(([^/]+\\\\/)${it.endsWith('?') ? '?' : ''})`;\n  } else if (it.startsWith('*')) {\n    return `((.*\\\\/)${it.endsWith('?') ? '?' : ''})`;\n  }\n\n  // Strip groups from the matcher\n  if (matchGroupName(it) != null) {\n    // Groups are optional segments\n    // this enables us to match `/bar` and `/(foo)/bar` for the same route\n    // NOTE(EvanBacon): Ignore this match in the regex to avoid capturing the group\n    return `(?:${escape(it)}\\\\/)?`;\n  }\n\n  return escape(it) + `\\\\/`;\n}\n\nconst createConfigItem = (\n  screen: string,\n  routeNames: string[],\n  pattern: string,\n  path: string,\n  hasChildren?: boolean,\n  parse?: ParseConfig,\n  _route?: any\n): RouteConfig => {\n  // Normalize pattern to remove any leading, trailing slashes, duplicate slashes etc.\n  pattern = pattern.split('/').filter(Boolean).join('/');\n\n  const regex = pattern\n    ? new RegExp(`^(${pattern.split('/').map(formatRegexPattern).join('')})$`)\n    : undefined;\n\n  return {\n    screen,\n    regex,\n    pattern,\n    path,\n    // The routeNames array is mutated, so copy it to keep the current state\n    routeNames: [...routeNames],\n    parse,\n    userReadableName: [...routeNames.slice(0, -1), path || screen].join('/'),\n    hasChildren: !!hasChildren,\n    _route,\n  };\n};\n\nconst findParseConfigForRoute = (\n  routeName: string,\n  routeConfigs: RouteConfig[]\n): ParseConfig | undefined => {\n  for (const config of routeConfigs) {\n    if (routeName === config.routeNames[config.routeNames.length - 1]) {\n      return config.parse;\n    }\n  }\n\n  return undefined;\n};\n\n// Try to find an initial route connected with the one passed\nconst findInitialRoute = (\n  routeName: string,\n  parentScreens: string[],\n  initialRoutes: InitialRouteConfig[]\n): string | undefined => {\n  for (const config of initialRoutes) {\n    if (equalHeritage(parentScreens, config.parentScreens)) {\n      // If the parents are the same but the route name doesn't match the initial route\n      // then we return the initial route.\n      return routeName !== config.initialRouteName ? config.initialRouteName : undefined;\n    }\n  }\n  return undefined;\n};\n\n// returns state object with values depending on whether\n// it is the end of state and if there is initialRoute for this level\nconst createStateObject = (\n  initialRoute: string | undefined,\n  route: ParsedRoute,\n  isEmpty: boolean\n): InitialState => {\n  if (isEmpty) {\n    if (initialRoute) {\n      return {\n        index: 1,\n        routes: [{ name: initialRoute }, route],\n      };\n    }\n    return {\n      routes: [route],\n    };\n  }\n\n  if (initialRoute) {\n    return {\n      index: 1,\n      routes: [{ name: initialRoute }, { ...route, state: { routes: [] } }],\n    };\n  }\n  return {\n    routes: [{ ...route, state: { routes: [] } }],\n  };\n};\n\nconst createNestedStateObject = (\n  path: string,\n  routes: ParsedRoute[],\n  routeConfigs: RouteConfig[],\n  initialRoutes: InitialRouteConfig[]\n) => {\n  let route = routes.shift() as ParsedRoute;\n  const parentScreens: string[] = [];\n\n  let initialRoute = findInitialRoute(route.name, parentScreens, initialRoutes);\n\n  parentScreens.push(route.name);\n\n  const state: InitialState = createStateObject(initialRoute, route, routes.length === 0);\n\n  if (routes.length > 0) {\n    let nestedState = state;\n\n    while ((route = routes.shift() as ParsedRoute)) {\n      initialRoute = findInitialRoute(route.name, parentScreens, initialRoutes);\n\n      const nestedStateIndex = nestedState.index || nestedState.routes.length - 1;\n\n      nestedState.routes[nestedStateIndex].state = createStateObject(\n        initialRoute,\n        route,\n        routes.length === 0\n      );\n\n      if (routes.length > 0) {\n        nestedState = nestedState.routes[nestedStateIndex].state as InitialState;\n      }\n\n      parentScreens.push(route.name);\n    }\n  }\n\n  route = findFocusedRoute(state) as ParsedRoute;\n\n  // Remove groups from the path while preserving a trailing slash.\n  route.path = stripGroupSegmentsFromPath(path);\n\n  const params = parseQueryParams(route.path, findParseConfigForRoute(route.name, routeConfigs));\n\n  if (params) {\n    route.params = Object.assign(Object.create(null), route.params) as Record<string, any>;\n    for (const [name, value] of Object.entries(params)) {\n      if (route.params?.[name]) {\n        if (process.env.NODE_ENV !== 'production') {\n          console.warn(\n            `Route '/${route.name}' with param '${name}' was specified both in the path and as a param, removing from path`\n          );\n        }\n      }\n\n      if (!route.params?.[name]) {\n        route.params[name] = value;\n        continue;\n      }\n    }\n\n    if (Object.keys(route.params).length === 0) {\n      delete route.params;\n    }\n  }\n\n  return state;\n};\n\nconst parseQueryParams = (path: string, parseConfig?: Record<string, (value: string) => any>) => {\n  const query = path.split('?')[1];\n  const searchParams = new URLSearchParams(query);\n  const params = Object.fromEntries(\n    // @ts-ignore: [Symbol.iterator] is indeed, available on every platform.\n    searchParams\n  );\n\n  if (parseConfig) {\n    Object.keys(params).forEach((name) => {\n      if (Object.hasOwnProperty.call(parseConfig, name) && typeof params[name] === 'string') {\n        params[name] = parseConfig[name](params[name] as string);\n      }\n    });\n  }\n\n  return Object.keys(params).length ? params : undefined;\n};\n\nconst baseUrlCache = new Map<string, RegExp>();\n\nfunction getBaseUrlRegex(baseUrl: string) {\n  if (baseUrlCache.has(baseUrl)) {\n    return baseUrlCache.get(baseUrl)!;\n  }\n  const regex = new RegExp(`^\\\\/?${escape(baseUrl)}`, 'g');\n  baseUrlCache.set(baseUrl, regex);\n  return regex;\n}\n\nexport function stripBaseUrl(\n  path: string,\n  baseUrl: string | undefined = process.env.EXPO_BASE_URL\n) {\n  if (process.env.NODE_ENV !== 'development') {\n    if (baseUrl) {\n      const reg = getBaseUrlRegex(baseUrl);\n      return path.replace(/^\\/+/g, '/').replace(reg, '');\n    }\n  }\n  return path;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}