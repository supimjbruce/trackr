{"ast":null,"code":"\"use strict\";var _slicedToArray=require(\"@babel/runtime/helpers/slicedToArray\");var _defineProperty=require(\"@babel/runtime/helpers/defineProperty\");function ownKeys(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);r&&(o=o.filter(function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable;})),t.push.apply(t,o);}return t;}function _objectSpread(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?ownKeys(Object(t),!0).forEach(function(r){_defineProperty(e,r,t[r]);}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):ownKeys(Object(t)).forEach(function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r));});}return e;}Object.defineProperty(exports,\"__esModule\",{value:true});exports.getNormalizedStatePath=exports.getRouteInfoFromState=void 0;var getStateFromPath_forks_1=require(\"./fork/getStateFromPath-forks\");function getRouteInfoFromState(getPathFromState,state,baseUrl){var _getPathFromState=getPathFromState(state,false),path=_getPathFromState.path;var qualified=getPathFromState(state,true);return _objectSpread({unstable_globalHref:path,pathname:(0,getStateFromPath_forks_1.stripBaseUrl)(path,baseUrl).split('?')['0'],isIndex:isIndexPath(state)},getNormalizedStatePath(qualified,baseUrl));}exports.getRouteInfoFromState=getRouteInfoFromState;function isIndexPath(state){var _state$index;var route=state.routes[(_state$index=state.index)!=null?_state$index:state.routes.length-1];if(route.state){return isIndexPath(route.state);}if(route.params&&'screen'in route.params){return route.params.screen==='index';}if(route.name.match(/.+\\/index$/))return true;return false;}function getNormalizedStatePath(_ref,baseUrl){var statePath=_ref.path,params=_ref.params;var _statePath$split=statePath.split('?'),_statePath$split2=_slicedToArray(_statePath$split,1),pathname=_statePath$split2[0];return{segments:(0,getStateFromPath_forks_1.stripBaseUrl)(pathname,baseUrl).split('/').filter(Boolean).map(decodeURIComponent),params:decodeParams(params)};}exports.getNormalizedStatePath=getNormalizedStatePath;function decodeParams(params){var parsed={};for(var _ref2 of Object.entries(params)){var _ref3=_slicedToArray(_ref2,2);var key=_ref3[0];var value=_ref3[1];try{if(key==='params'&&typeof value==='object'){parsed[key]=decodeParams(value);}else if(Array.isArray(value)){parsed[key]=value.map(function(v){return decodeURIComponent(v);});}else{parsed[key]=decodeURIComponent(value);}}catch(_unused){parsed[key]=value;}}return parsed;}","map":{"version":3,"names":["getStateFromPath_forks_1","require","getRouteInfoFromState","getPathFromState","state","baseUrl","_getPathFromState","path","qualified","_objectSpread","unstable_globalHref","pathname","stripBaseUrl","split","isIndex","isIndexPath","getNormalizedStatePath","exports","_state$index","route","routes","index","length","params","screen","name","match","_ref","statePath","_statePath$split","_statePath$split2","_slicedToArray","segments","filter","Boolean","map","decodeURIComponent","decodeParams","parsed","_ref2","Object","entries","_ref3","key","value","Array","isArray","v","_unused"],"sources":["/Users/jonathanbruce/Coding/trackr/node_modules/expo-router/src/LocationProvider.tsx"],"sourcesContent":["import { type State } from './fork/getPathFromState';\nimport { stripBaseUrl } from './fork/getStateFromPath-forks';\n\ntype SearchParams = Record<string, string | string[]>;\n\nexport type UrlObject = {\n  unstable_globalHref: string;\n  pathname: string;\n  readonly params: SearchParams;\n  segments: string[];\n  isIndex: boolean;\n};\n\nexport function getRouteInfoFromState(\n  getPathFromState: (state: State, asPath: boolean) => { path: string; params: any },\n  state: State,\n  baseUrl?: string\n): UrlObject {\n  const { path } = getPathFromState(state, false);\n  const qualified = getPathFromState(state, true);\n\n  return {\n    // TODO: This may have a predefined origin attached in the future.\n    unstable_globalHref: path,\n    pathname: stripBaseUrl(path, baseUrl).split('?')['0'],\n    isIndex: isIndexPath(state),\n    ...getNormalizedStatePath(qualified, baseUrl),\n  };\n}\n\nfunction isIndexPath(state: State) {\n  const route = state.routes[state.index ?? state.routes.length - 1];\n  if (route.state) {\n    return isIndexPath(route.state);\n  }\n\n  // Index routes on the same level as a layout do not have `index` in their name\n  if (route.params && 'screen' in route.params) {\n    return route.params.screen === 'index';\n  }\n\n  // The `params` key will not exist if there are no params\n  // So we need to do a positive lookahead to check if the route ends with /index\n  // Nested routes that are hoisted will have a name ending with /index\n  // e.g name could be /user/[id]/index\n  if (route.name.match(/.+\\/index$/)) return true;\n\n  // The state will either have params (because there are multiple _layout) or it will be hoisted with a name\n  // If we don't match the above cases, then it's not an index route\n\n  return false;\n}\n\n// TODO: Split up getPathFromState to return all this info at once.\nexport function getNormalizedStatePath(\n  {\n    path: statePath,\n    params,\n  }: {\n    path: string;\n    params: any;\n  },\n  baseUrl?: string\n): Pick<UrlObject, 'segments' | 'params'> {\n  const [pathname] = statePath.split('?');\n  return {\n    // Strip empty path at the start\n    segments: stripBaseUrl(pathname, baseUrl).split('/').filter(Boolean).map(decodeURIComponent),\n    // TODO: This is not efficient, we should generate based on the state instead\n    // of converting to string then back to object\n    params: decodeParams(params),\n  };\n}\n\nfunction decodeParams(params: Record<string, string>) {\n  const parsed: Record<string, any> = {};\n\n  for (const [key, value] of Object.entries(params)) {\n    try {\n      if (key === 'params' && typeof value === 'object') {\n        parsed[key] = decodeParams(value);\n      } else if (Array.isArray(value)) {\n        parsed[key] = value.map((v) => decodeURIComponent(v));\n      } else {\n        parsed[key] = decodeURIComponent(value);\n      }\n    } catch {\n      parsed[key] = value;\n    }\n  }\n\n  return parsed;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}