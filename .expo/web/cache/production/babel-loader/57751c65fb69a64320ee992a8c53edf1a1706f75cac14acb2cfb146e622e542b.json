{"ast":null,"code":"\"use strict\";var _defineProperty=require(\"@babel/runtime/helpers/defineProperty\");function ownKeys(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);r&&(o=o.filter(function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable;})),t.push.apply(t,o);}return t;}function _objectSpread(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?ownKeys(Object(t),!0).forEach(function(r){_defineProperty(e,r,t[r]);}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):ownKeys(Object(t)).forEach(function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r));});}return e;}var __createBinding=this&&this.__createBinding||(Object.create?function(o,m,k,k2){if(k2===undefined)k2=k;var desc=Object.getOwnPropertyDescriptor(m,k);if(!desc||(\"get\"in desc?!m.__esModule:desc.writable||desc.configurable)){desc={enumerable:true,get:function get(){return m[k];}};}Object.defineProperty(o,k2,desc);}:function(o,m,k,k2){if(k2===undefined)k2=k;o[k2]=m[k];});var __setModuleDefault=this&&this.__setModuleDefault||(Object.create?function(o,v){Object.defineProperty(o,\"default\",{enumerable:true,value:v});}:function(o,v){o[\"default\"]=v;});var __importStar=this&&this.__importStar||function(mod){if(mod&&mod.__esModule)return mod;var result={};if(mod!=null)for(var k in mod)if(k!==\"default\"&&Object.prototype.hasOwnProperty.call(mod,k))__createBinding(result,mod,k);__setModuleDefault(result,mod);return result;};Object.defineProperty(exports,\"__esModule\",{value:true});exports.linkTo=exports.setParams=exports.canDismiss=exports.canGoBack=exports.goBack=exports.dismissAll=exports.replace=exports.dismissTo=exports.dismiss=exports.push=exports.reload=exports.navigate=void 0;var native_1=require(\"@react-navigation/native\");var dom_1=require(\"expo/dom\");var Linking=__importStar(require(\"expo-linking\"));var non_secure_1=require(\"nanoid/non-secure\");var react_native_1=require(\"react-native-web/dist/index\");var href_1=require(\"../link/href\");var useDomComponentNavigation_1=require(\"../link/useDomComponentNavigation\");var matchers_1=require(\"../matchers\");var url_1=require(\"../utils/url\");function assertIsReady(store){if(!store.navigationRef.isReady()){throw new Error('Attempted to navigate before mounting the Root Layout component. Ensure the Root Layout component is rendering a Slot, or other navigator on the first render.');}}function navigate(url,options){return this.linkTo((0,href_1.resolveHref)(url),_objectSpread(_objectSpread({},options),{},{event:'NAVIGATE'}));}exports.navigate=navigate;function reload(){throw new Error('The reload method is not implemented in the client-side router yet.');}exports.reload=reload;function push(url,options){return this.linkTo((0,href_1.resolveHref)(url),_objectSpread(_objectSpread({},options),{},{event:'PUSH'}));}exports.push=push;function dismiss(count){var _this$navigationRef;if((0,useDomComponentNavigation_1.emitDomDismiss)(count)){return;}(_this$navigationRef=this.navigationRef)==null?void 0:_this$navigationRef.dispatch(native_1.StackActions.pop(count));}exports.dismiss=dismiss;function dismissTo(href,options){return this.linkTo((0,href_1.resolveHref)(href),_objectSpread(_objectSpread({},options),{},{event:'POP_TO'}));}exports.dismissTo=dismissTo;function replace(url,options){return this.linkTo((0,href_1.resolveHref)(url),_objectSpread(_objectSpread({},options),{},{event:'REPLACE'}));}exports.replace=replace;function dismissAll(){var _this$navigationRef2;if((0,useDomComponentNavigation_1.emitDomDismissAll)()){return;}(_this$navigationRef2=this.navigationRef)==null?void 0:_this$navigationRef2.dispatch(native_1.StackActions.popToTop());}exports.dismissAll=dismissAll;function goBack(){var _this$navigationRef3,_this$navigationRef3$;if((0,useDomComponentNavigation_1.emitDomGoBack)()){return;}assertIsReady(this);(_this$navigationRef3=this.navigationRef)==null?void 0:(_this$navigationRef3$=_this$navigationRef3.current)==null?void 0:_this$navigationRef3$.goBack();}exports.goBack=goBack;function canGoBack(){var _this$navigationRef$c,_this$navigationRef4,_this$navigationRef4$;if(dom_1.IS_DOM){throw new Error('canGoBack imperative method is not supported. Pass the property to the DOM component instead.');}if(!this.navigationRef.isReady()){return false;}return(_this$navigationRef$c=(_this$navigationRef4=this.navigationRef)==null?void 0:(_this$navigationRef4$=_this$navigationRef4.current)==null?void 0:_this$navigationRef4$.canGoBack())!=null?_this$navigationRef$c:false;}exports.canGoBack=canGoBack;function canDismiss(){if(dom_1.IS_DOM){throw new Error('canDismiss imperative method is not supported. Pass the property to the DOM component instead.');}var state=this.rootState;while(state){var _state$routes,_state$routes$state$i;if(state.type==='stack'&&state.routes.length>1){return true;}if(state.index===undefined)return false;state=(_state$routes=state.routes)==null?void 0:(_state$routes$state$i=_state$routes[state.index])==null?void 0:_state$routes$state$i.state;}return false;}exports.canDismiss=canDismiss;function setParams(){var _this$navigationRef5,_this$navigationRef5$;var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};if((0,useDomComponentNavigation_1.emitDomSetParams)(params)){return;}assertIsReady(this);return((_this$navigationRef5=this.navigationRef)==null?void 0:(_this$navigationRef5$=_this$navigationRef5.current)==null?void 0:_this$navigationRef5$.setParams.bind(_this$navigationRef5$))(params);}exports.setParams=setParams;function linkTo(href){var _ref=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{},event=_ref.event,relativeToDirectory=_ref.relativeToDirectory,withAnchor=_ref.withAnchor;if((0,useDomComponentNavigation_1.emitDomLinkEvent)(href,{event:event,relativeToDirectory:relativeToDirectory,withAnchor:withAnchor})){return;}if((0,url_1.shouldLinkExternally)(href)){if(href.startsWith('//')&&react_native_1.Platform.OS!=='web'){href=`https:${href}`;}Linking.openURL(href);return;}assertIsReady(this);var navigationRef=this.navigationRef.current;if(navigationRef==null){throw new Error(\"Couldn't find a navigation object. Is your component inside NavigationContainer?\");}if(!this.linking){throw new Error('Attempted to link to route when no routes are present');}if(href==='..'||href==='../'){navigationRef.goBack();return;}var rootState=navigationRef.getRootState();href=(0,href_1.resolveHrefStringWithSegments)(href,this.routeInfo,relativeToDirectory);var state=this.linking.getStateFromPath(href,this.linking.config);if(!state||state.routes.length===0){console.error('Could not generate a valid navigation state for the given path: '+href);return;}return navigationRef.dispatch(getNavigateAction(state,rootState,event,withAnchor));}exports.linkTo=linkTo;function getNavigateAction(actionState,navigationState){var type=arguments.length>2&&arguments[2]!==undefined?arguments[2]:'NAVIGATE';var withAnchor=arguments.length>3?arguments[3]:undefined;var actionStateRoute;while(actionState&&navigationState){var _actionStateRoute$par,_stateRoute$params;var stateRoute=navigationState.routes[navigationState.index];actionStateRoute=actionState.routes[actionState.routes.length-1];var childState=actionStateRoute.state;var nextNavigationState=stateRoute.state;var dynamicName=(0,matchers_1.matchDynamicName)(actionStateRoute.name);var didActionAndCurrentStateDiverge=actionStateRoute.name!==stateRoute.name||!childState||!nextNavigationState||dynamicName&&((_actionStateRoute$par=actionStateRoute.params)==null?void 0:_actionStateRoute$par[dynamicName])!==((_stateRoute$params=stateRoute.params)==null?void 0:_stateRoute$params[dynamicName]);if(didActionAndCurrentStateDiverge){break;}actionState=childState;navigationState=nextNavigationState;}var rootPayload={params:{}};var payload=rootPayload;var params=payload.params;while(actionStateRoute){var _actionStateRoute$sta,_actionStateRoute$sta2;Object.assign(params,_objectSpread(_objectSpread({},payload.params),actionStateRoute.params));payload.screen=actionStateRoute.name;payload.params=_objectSpread({},params);delete payload.params['screen'];payload=payload.params;params=payload;actionStateRoute=(_actionStateRoute$sta=actionStateRoute.state)==null?void 0:_actionStateRoute$sta.routes[((_actionStateRoute$sta2=actionStateRoute.state)==null?void 0:_actionStateRoute$sta2.routes.length)-1];}if(type==='PUSH'){type='NAVIGATE';if(navigationState.type==='stack'){rootPayload.params.__EXPO_ROUTER_key=`${rootPayload.name}-${(0,non_secure_1.nanoid)()}`;}}if(navigationState.type==='expo-tab'){type='JUMP_TO';}if(type==='REPLACE'&&(navigationState.type==='tab'||navigationState.type==='drawer')){type='JUMP_TO';}if(withAnchor!==undefined){if(rootPayload.params.initial){if(\"production\"!=='production'){console.warn(`The parameter 'initial' is a reserved parameter name in React Navigation`);}}rootPayload.params.initial=!withAnchor;}return{type:type,target:navigationState.key,payload:{name:rootPayload.screen,params:rootPayload.params}};}","map":{"version":3,"names":["native_1","require","dom_1","Linking","__importStar","non_secure_1","react_native_1","href_1","useDomComponentNavigation_1","matchers_1","url_1","assertIsReady","store","navigationRef","isReady","Error","navigate","url","options","linkTo","resolveHref","_objectSpread","event","exports","reload","push","dismiss","count","_this$navigationRef","emitDomDismiss","dispatch","StackActions","pop","dismissTo","href","replace","dismissAll","_this$navigationRef2","emitDomDismissAll","popToTop","goBack","_this$navigationRef3","_this$navigationRef3$","emitDomGoBack","current","canGoBack","_this$navigationRef$c","_this$navigationRef4","_this$navigationRef4$","IS_DOM","canDismiss","state","rootState","_state$routes","_state$routes$state$i","type","routes","length","index","undefined","setParams","_this$navigationRef5","_this$navigationRef5$","params","arguments","emitDomSetParams","bind","_ref","relativeToDirectory","withAnchor","emitDomLinkEvent","shouldLinkExternally","startsWith","Platform","OS","openURL","linking","getRootState","resolveHrefStringWithSegments","routeInfo","getStateFromPath","config","console","error","getNavigateAction","actionState","navigationState","actionStateRoute","_actionStateRoute$par","_stateRoute$params","stateRoute","childState","nextNavigationState","dynamicName","matchDynamicName","name","didActionAndCurrentStateDiverge","rootPayload","payload","_actionStateRoute$sta","_actionStateRoute$sta2","Object","assign","screen","__EXPO_ROUTER_key","nanoid","initial","warn","target","key"],"sources":["/Users/jonathanbruce/Coding/trackr/node_modules/expo-router/src/global-state/routing.ts"],"sourcesContent":["import { StackActions, type NavigationState, PartialRoute } from '@react-navigation/native';\nimport { IS_DOM } from 'expo/dom';\nimport * as Linking from 'expo-linking';\nimport { nanoid } from 'nanoid/non-secure';\nimport { Platform } from 'react-native';\n\nimport { type RouterStore } from './router-store';\nimport { ResultState } from '../fork/getStateFromPath';\nimport { resolveHref, resolveHrefStringWithSegments } from '../link/href';\nimport {\n  emitDomDismiss,\n  emitDomDismissAll,\n  emitDomGoBack,\n  emitDomLinkEvent,\n  emitDomSetParams,\n} from '../link/useDomComponentNavigation';\nimport { matchDynamicName } from '../matchers';\nimport { Href } from '../types';\nimport { shouldLinkExternally } from '../utils/url';\n\nfunction assertIsReady(store: RouterStore) {\n  if (!store.navigationRef.isReady()) {\n    throw new Error(\n      'Attempted to navigate before mounting the Root Layout component. Ensure the Root Layout component is rendering a Slot, or other navigator on the first render.'\n    );\n  }\n}\n\nexport type NavigationOptions = Omit<LinkToOptions, 'event'>;\n\nexport function navigate(this: RouterStore, url: Href, options?: NavigationOptions) {\n  return this.linkTo(resolveHref(url), { ...options, event: 'NAVIGATE' });\n}\n\nexport function reload(this: RouterStore) {\n  // TODO(EvanBacon): add `reload` support.\n  throw new Error('The reload method is not implemented in the client-side router yet.');\n}\n\nexport function push(this: RouterStore, url: Href, options?: NavigationOptions) {\n  return this.linkTo(resolveHref(url), { ...options, event: 'PUSH' });\n}\n\nexport function dismiss(this: RouterStore, count?: number) {\n  if (emitDomDismiss(count)) {\n    return;\n  }\n  this.navigationRef?.dispatch(StackActions.pop(count));\n}\n\nexport function dismissTo(this: RouterStore, href: Href, options?: NavigationOptions) {\n  return this.linkTo(resolveHref(href), { ...options, event: 'POP_TO' });\n}\n\nexport function replace(this: RouterStore, url: Href, options?: NavigationOptions) {\n  return this.linkTo(resolveHref(url), { ...options, event: 'REPLACE' });\n}\n\nexport function dismissAll(this: RouterStore) {\n  if (emitDomDismissAll()) {\n    return;\n  }\n  this.navigationRef?.dispatch(StackActions.popToTop());\n}\n\nexport function goBack(this: RouterStore) {\n  if (emitDomGoBack()) {\n    return;\n  }\n  assertIsReady(this);\n  this.navigationRef?.current?.goBack();\n}\n\nexport function canGoBack(this: RouterStore): boolean {\n  if (IS_DOM) {\n    throw new Error(\n      'canGoBack imperative method is not supported. Pass the property to the DOM component instead.'\n    );\n  }\n  // Return a default value here if the navigation hasn't mounted yet.\n  // This can happen if the user calls `canGoBack` from the Root Layout route\n  // before mounting a navigator. This behavior exists due to React Navigation being dynamically\n  // constructed at runtime. We can get rid of this in the future if we use\n  // the static configuration internally.\n  if (!this.navigationRef.isReady()) {\n    return false;\n  }\n  return this.navigationRef?.current?.canGoBack() ?? false;\n}\n\nexport function canDismiss(this: RouterStore): boolean {\n  if (IS_DOM) {\n    throw new Error(\n      'canDismiss imperative method is not supported. Pass the property to the DOM component instead.'\n    );\n  }\n  let state = this.rootState;\n\n  // Keep traversing down the state tree until we find a stack navigator that we can pop\n  while (state) {\n    if (state.type === 'stack' && state.routes.length > 1) {\n      return true;\n    }\n    if (state.index === undefined) return false;\n\n    state = state.routes?.[state.index]?.state as any;\n  }\n\n  return false;\n}\n\nexport function setParams(\n  this: RouterStore,\n  params: Record<string, string | number | (string | number)[]> = {}\n) {\n  if (emitDomSetParams(params)) {\n    return;\n  }\n  assertIsReady(this);\n  return (this.navigationRef?.current?.setParams as any)(params);\n}\n\nexport type LinkToOptions = {\n  event?: string;\n\n  /**\n   * Relative URL references are either relative to the directory or the document. By default, relative paths are relative to the document.\n   * @see: [MDN's documentation on Resolving relative references to a URL](https://developer.mozilla.org/en-US/docs/Web/API/URL_API/Resolving_relative_references).\n   */\n  relativeToDirectory?: boolean;\n\n  /**\n   *\n   */\n  withAnchor?: boolean;\n};\n\nexport function linkTo(\n  this: RouterStore,\n  href: string,\n  { event, relativeToDirectory, withAnchor }: LinkToOptions = {}\n) {\n  if (emitDomLinkEvent(href, { event, relativeToDirectory, withAnchor })) {\n    return;\n  }\n\n  if (shouldLinkExternally(href)) {\n    if (href.startsWith('//') && Platform.OS !== 'web') {\n      href = `https:${href}`;\n    }\n\n    Linking.openURL(href);\n    return;\n  }\n\n  assertIsReady(this);\n  const navigationRef = this.navigationRef.current;\n\n  if (navigationRef == null) {\n    throw new Error(\n      \"Couldn't find a navigation object. Is your component inside NavigationContainer?\"\n    );\n  }\n\n  if (!this.linking) {\n    throw new Error('Attempted to link to route when no routes are present');\n  }\n\n  if (href === '..' || href === '../') {\n    navigationRef.goBack();\n    return;\n  }\n\n  const rootState = navigationRef.getRootState();\n\n  href = resolveHrefStringWithSegments(href, this.routeInfo, relativeToDirectory);\n\n  const state = this.linking.getStateFromPath!(href, this.linking.config);\n\n  if (!state || state.routes.length === 0) {\n    console.error('Could not generate a valid navigation state for the given path: ' + href);\n    return;\n  }\n\n  return navigationRef.dispatch(getNavigateAction(state, rootState, event, withAnchor));\n}\n\nfunction getNavigateAction(\n  actionState: ResultState,\n  navigationState: NavigationState,\n  type = 'NAVIGATE',\n  withAnchor?: boolean\n) {\n  /**\n   * We need to find the deepest navigator where the action and current state diverge, If they do not diverge, the\n   * lowest navigator is the target.\n   *\n   * By default React Navigation will target the current navigator, but this doesn't work for all actions\n   * For example:\n   *  - /deeply/nested/route -> /top-level-route the target needs to be the top-level navigator\n   *  - /stack/nestedStack/page -> /stack1/nestedStack/other-page needs to target the nestedStack navigator\n   *\n   * This matching needs to done by comparing the route names and the dynamic path, for example\n   * - /1/page -> /2/anotherPage needs to target the /[id] navigator\n   *\n   * Other parameters such as search params and hash are not evaluated.\n   */\n  let actionStateRoute: PartialRoute<any> | undefined;\n\n  // Traverse the state tree comparing the current state and the action state until we find where they diverge\n  while (actionState && navigationState) {\n    const stateRoute = navigationState.routes[navigationState.index];\n\n    actionStateRoute = actionState.routes[actionState.routes.length - 1];\n\n    const childState = actionStateRoute.state;\n    const nextNavigationState = stateRoute.state;\n\n    const dynamicName = matchDynamicName(actionStateRoute.name);\n\n    const didActionAndCurrentStateDiverge =\n      actionStateRoute.name !== stateRoute.name ||\n      !childState ||\n      !nextNavigationState ||\n      (dynamicName && actionStateRoute.params?.[dynamicName] !== stateRoute.params?.[dynamicName]);\n\n    if (didActionAndCurrentStateDiverge) {\n      break;\n    }\n\n    actionState = childState;\n    navigationState = nextNavigationState as NavigationState;\n  }\n\n  /*\n   * We found the target navigator, but the payload is in the incorrect format\n   * We need to convert the action state to a payload that can be dispatched\n   */\n  const rootPayload: Record<string, any> = { params: {} };\n  let payload = rootPayload;\n  let params = payload.params;\n\n  // The root level of payload is a bit weird, its params are in the child object\n  while (actionStateRoute) {\n    Object.assign(params, { ...payload.params, ...actionStateRoute.params });\n    // Assign the screen name to the payload\n    payload.screen = actionStateRoute.name;\n    // Merge the params, ensuring that we create a new object\n    payload.params = { ...params };\n    // Params don't include the screen, thats a separate attribute\n    delete payload.params['screen'];\n\n    // Continue down the payload tree\n    // Initially these values are separate, but React Nav merges them after the first layer\n    payload = payload.params;\n    params = payload;\n\n    actionStateRoute = actionStateRoute.state?.routes[actionStateRoute.state?.routes.length - 1];\n  }\n\n  // Expo Router uses only three actions, but these don't directly translate to all navigator actions\n  if (type === 'PUSH') {\n    // Only stack navigators have a push action, and even then we want to use NAVIGATE (see below)\n    type = 'NAVIGATE';\n\n    /*\n     * The StackAction.PUSH does not work correctly with Expo Router.\n     *\n     * Expo Router provides a getId() function for every route, altering how React Navigation handles stack routing.\n     * Ordinarily, PUSH always adds a new screen to the stack. However, with getId() present, it navigates to the screen with the matching ID instead (by moving the screen to the top of the stack)\n     * When you try and push to a screen with the same ID, no navigation will occur\n     * Refer to: https://github.com/react-navigation/react-navigation/blob/13d4aa270b301faf07960b4cd861ffc91e9b2c46/packages/routers/src/StackRouter.tsx#L279-L290\n     *\n     * Expo Router needs to retain the default behavior of PUSH, consistently adding new screens to the stack, even if their IDs are identical.\n     *\n     * To resolve this issue, we switch to using a NAVIGATE action with a new key. In the navigate action, screens are matched by either key or getId() function.\n     * By generating a unique new key, we ensure that the screen is always pushed onto the stack.\n     *\n     */\n    if (navigationState.type === 'stack') {\n      rootPayload.params.__EXPO_ROUTER_key = `${rootPayload.name}-${nanoid()}`; // @see https://github.com/react-navigation/react-navigation/blob/13d4aa270b301faf07960b4cd861ffc91e9b2c46/packages/routers/src/StackRouter.tsx#L406-L407\n    }\n  }\n\n  if (navigationState.type === 'expo-tab') {\n    type = 'JUMP_TO';\n  }\n\n  if (type === 'REPLACE' && (navigationState.type === 'tab' || navigationState.type === 'drawer')) {\n    type = 'JUMP_TO';\n  }\n\n  if (withAnchor !== undefined) {\n    if (rootPayload.params.initial) {\n      if (process.env.NODE_ENV !== 'production') {\n        console.warn(`The parameter 'initial' is a reserved parameter name in React Navigation`);\n      }\n    }\n    /*\n     * The logic for initial can seen backwards depending on your perspective\n     *   True: The initialRouteName is not loaded. The incoming screen is the initial screen (default)\n     *   False: The initialRouteName is loaded. THe incoming screen is placed after the initialRouteName\n     *\n     * withAnchor flips the perspective.\n     *   True: You want the initialRouteName to load.\n     *   False: You do not want the initialRouteName to load.\n     */\n    rootPayload.params.initial = !withAnchor;\n  }\n\n  return {\n    type,\n    target: navigationState.key,\n    payload: {\n      // key: rootPayload.key,\n      name: rootPayload.screen,\n      params: rootPayload.params,\n    },\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}