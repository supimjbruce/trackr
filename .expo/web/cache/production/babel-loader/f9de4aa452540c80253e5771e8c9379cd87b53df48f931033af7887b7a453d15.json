{"ast":null,"code":"\"use strict\";var _defineProperty=require(\"@babel/runtime/helpers/defineProperty\");function ownKeys(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);r&&(o=o.filter(function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable;})),t.push.apply(t,o);}return t;}function _objectSpread(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?ownKeys(Object(t),!0).forEach(function(r){_defineProperty(e,r,t[r]);}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):ownKeys(Object(t)).forEach(function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r));});}return e;}Object.defineProperty(exports,\"__esModule\",{value:true});exports.stateCache=exports.getLinkingConfig=exports.getNavigationConfig=void 0;var native_1=require(\"@react-navigation/native\");var getReactNavigationConfig_1=require(\"./getReactNavigationConfig\");var linking_1=require(\"./link/linking\");function getNavigationConfig(routes){return(0,getReactNavigationConfig_1.getReactNavigationConfig)(routes,true);}exports.getNavigationConfig=getNavigationConfig;function getLinkingConfig(routes){return{prefixes:[],config:getNavigationConfig(routes),getInitialURL:linking_1.getInitialURL,subscribe:linking_1.addEventListener,getStateFromPath:getStateFromPathMemoized,getPathFromState:function getPathFromState(state,options){var _ref;return(_ref=(0,linking_1.getPathFromState)(state,_objectSpread(_objectSpread({screens:[]},this.config),options)))!=null?_ref:'/';},getActionFromState:native_1.getActionFromState};}exports.getLinkingConfig=getLinkingConfig;exports.stateCache=new Map();function getStateFromPathMemoized(path,options){var cached=exports.stateCache.get(path);if(cached){return cached;}var result=(0,linking_1.getStateFromPath)(path,options);exports.stateCache.set(path,result);return result;}","map":{"version":3,"names":["native_1","require","getReactNavigationConfig_1","linking_1","getNavigationConfig","routes","getReactNavigationConfig","exports","getLinkingConfig","prefixes","config","getInitialURL","subscribe","addEventListener","getStateFromPath","getStateFromPathMemoized","getPathFromState","state","options","_ref","_objectSpread","screens","getActionFromState","stateCache","Map","path","cached","get","result","set"],"sources":["/Users/jonathanbruce/Coding/trackr/node_modules/expo-router/src/getLinkingConfig.ts"],"sourcesContent":["import { getActionFromState, LinkingOptions } from '@react-navigation/native';\n\nimport { RouteNode } from './Route';\nimport { State } from './fork/getPathFromState';\nimport { getReactNavigationConfig, Screen } from './getReactNavigationConfig';\nimport {\n  addEventListener,\n  getInitialURL,\n  getPathFromState,\n  getStateFromPath,\n} from './link/linking';\n\nexport function getNavigationConfig(routes: RouteNode): {\n  initialRouteName?: string;\n  screens: Record<string, Screen>;\n} {\n  return getReactNavigationConfig(routes, true);\n}\n\nexport type ExpoLinkingOptions = LinkingOptions<object> & {\n  getPathFromState?: typeof getPathFromState;\n};\n\nexport function getLinkingConfig(routes: RouteNode): ExpoLinkingOptions {\n  return {\n    prefixes: [],\n    // @ts-expect-error\n    config: getNavigationConfig(routes),\n    // A custom getInitialURL is used on native to ensure the app always starts at\n    // the root path if it's launched from something other than a deep link.\n    // This helps keep the native functionality working like the web functionality.\n    // For example, if you had a root navigator where the first screen was `/settings` and the second was `/index`\n    // then `/index` would be used on web and `/settings` would be used on native.\n    getInitialURL,\n    subscribe: addEventListener,\n    getStateFromPath: getStateFromPathMemoized,\n    getPathFromState(state: State, options: Parameters<typeof getPathFromState>[1]) {\n      return (\n        getPathFromState(state, {\n          screens: [],\n          ...this.config,\n          ...options,\n        }) ?? '/'\n      );\n    },\n    // Add all functions to ensure the types never need to fallback.\n    // This is a convenience for usage in the package.\n    getActionFromState,\n  };\n}\n\nexport const stateCache = new Map<string, any>();\n\n/** We can reduce work by memoizing the state by the pathname. This only works because the options (linking config) theoretically never change.  */\nfunction getStateFromPathMemoized(path: string, options: Parameters<typeof getStateFromPath>[1]) {\n  const cached = stateCache.get(path);\n  if (cached) {\n    return cached;\n  }\n  const result = getStateFromPath(path, options);\n  stateCache.set(path, result);\n  return result;\n}\n"],"mappings":"s0BAAA,IAAAA,QAAA,CAAAC,OAAA,6BAIA,IAAAC,0BAAA,CAAAD,OAAA,+BACA,IAAAE,SAAA,CAAAF,OAAA,mBAOA,QAAgB,CAAAG,mBAAmBA,CAACC,MAAiB,EAInD,MAAO,GAAAH,0BAAA,CAAAI,wBAAwB,EAACD,MAAM,CAAE,IAAI,CAAC,CAC/C,CALAE,OAAA,CAAAH,mBAAA,CAAAA,mBAAA,CAWA,QAAgB,CAAAI,gBAAgBA,CAACH,MAAiB,EAChD,MAAO,CACLI,QAAQ,CAAE,EAAE,CAEZC,MAAM,CAAEN,mBAAmB,CAACC,MAAM,CAAC,CAMnCM,aAAa,CAAbR,SAAA,CAAAQ,aAAa,CACbC,SAAS,CAAET,SAAA,CAAAU,gBAAgB,CAC3BC,gBAAgB,CAAEC,wBAAwB,CAC1CC,gBAAgB,SAAhB,CAAAA,gBAAgBA,CAACC,KAAY,CAAEC,OAA+C,MAAAC,IAAA,CAC5E,OAAAA,IAAA,CACE,GAAAhB,SAAA,CAAAa,gBAAgB,EAACC,KAAK,CAAAG,aAAA,CAAAA,aAAA,EACpBC,OAAO,CAAE,EAAE,EACR,IAAI,CAACX,MAAM,EACXQ,OAAO,CACX,CAAC,QAAAC,IAAA,CAAI,GAAG,CAEb,CAAC,CAGDG,kBAAkB,CAAlBtB,QAAA,CAAAsB,kB,CACD,CACH,CA1BAf,OAAA,CAAAC,gBAAA,CAAAA,gBAAA,CA4BaD,OAAA,CAAAgB,UAAU,CAAG,GAAI,CAAAC,GAAG,EAAe,CAGhD,QAAS,CAAAT,wBAAwBA,CAACU,IAAY,CAAEP,OAA+C,EAC7F,GAAM,CAAAQ,MAAM,CAAGnB,OAAA,CAAAgB,UAAU,CAACI,GAAG,CAACF,IAAI,CAAC,CACnC,GAAIC,MAAM,CAAE,CACV,MAAO,CAAAA,MAAM,C,CAEf,GAAM,CAAAE,MAAM,CAAG,GAAAzB,SAAA,CAAAW,gBAAgB,EAACW,IAAI,CAAEP,OAAO,CAAC,CAC9CX,OAAA,CAAAgB,UAAU,CAACM,GAAG,CAACJ,IAAI,CAAEG,MAAM,CAAC,CAC5B,MAAO,CAAAA,MAAM,CACf","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}