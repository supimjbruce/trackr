{"ast":null,"code":"\"use strict\";var _toConsumableArray=require(\"@babel/runtime/helpers/toConsumableArray\");var _defineProperty=require(\"@babel/runtime/helpers/defineProperty\");var _slicedToArray=require(\"@babel/runtime/helpers/slicedToArray\");var _objectWithoutProperties=require(\"@babel/runtime/helpers/objectWithoutProperties\");var _excluded=[\"preserveGroups\",\"preserveDynamicRoutes\"];function ownKeys(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);r&&(o=o.filter(function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable;})),t.push.apply(t,o);}return t;}function _objectSpread(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?ownKeys(Object(t),!0).forEach(function(r){_defineProperty(e,r,t[r]);}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):ownKeys(Object(t)).forEach(function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r));});}return e;}Object.defineProperty(exports,\"__esModule\",{value:true});exports.appendBaseUrl=exports.deepEqual=exports.getPathDataFromState=void 0;var core_1=require(\"@react-navigation/core\");var matchers_1=require(\"../matchers\");var DEFAULT_SCREENS={};var _getActiveRoute=function getActiveRoute(state){var route=typeof state.index==='number'?state.routes[state.index]:state.routes[state.routes.length-1];if(route.state){return _getActiveRoute(route.state);}if(route&&isInvalidParams(route.params)){return _getActiveRoute(createFakeState(route.params));}return route;};function createFakeState(params){return{stale:false,type:'UNKNOWN',key:'UNKNOWN',index:0,routeNames:[],routes:[{key:'UNKNOWN',name:params.screen,params:params.params,path:params.path}]};}function segmentMatchesConvention(segment){return segment==='index'||(0,matchers_1.matchDynamicName)(segment)!=null||(0,matchers_1.matchGroupName)(segment)!=null||(0,matchers_1.matchDeepDynamicRouteName)(segment)!=null;}function encodeURIComponentPreservingBrackets(str){return encodeURIComponent(str).replace(/%5B/g,'[').replace(/%5D/g,']');}function getPathFromState(state,_options){return getPathDataFromState(state,_options).path;}exports.default=getPathFromState;function getPathDataFromState(state){var _options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{screens:DEFAULT_SCREENS};if(state==null){throw Error(\"Got 'undefined' for the navigation state. You must pass a valid state object.\");}var preserveGroups=_options.preserveGroups,preserveDynamicRoutes=_options.preserveDynamicRoutes,options=_objectWithoutProperties(_options,_excluded);(0,core_1.validatePathConfig)(options);if(Object.is(options.screens,DEFAULT_SCREENS)){throw Error(\"You must pass a 'screens' object to 'getPathFromState' to generate a path.\");}return getPathFromResolvedState(JSON.parse(JSON.stringify(state)),createNormalizedConfigs(options.screens),{preserveGroups:preserveGroups,preserveDynamicRoutes:preserveDynamicRoutes});}exports.getPathDataFromState=getPathDataFromState;function processParamsWithUserSettings(configItem,params){var stringify=configItem==null?void 0:configItem.stringify;return Object.fromEntries(Object.entries(params).map(function(_ref){var _ref2=_slicedToArray(_ref,2),key=_ref2[0],value=_ref2[1];return[key,stringify!=null&&stringify[key]?stringify[key](value):Array.isArray(value)?value:String(value)];}));}function deepEqual(a,b){if(a===b){return true;}if(Array.isArray(a)&&Array.isArray(b)){if(a.length!==b.length){return false;}for(var i=0;i<a.length;i++){if(!deepEqual(a[i],b[i])){return false;}}return true;}if(typeof a==='object'&&typeof b==='object'){var keysA=Object.keys(a);var keysB=Object.keys(b);if(keysA.length!==keysB.length){return false;}for(var key of keysA){if(!deepEqual(a[key],b[key])){return false;}}return true;}return false;}exports.deepEqual=deepEqual;function walkConfigItems(route,focusedRoute,configs,_ref3){var preserveDynamicRoutes=_ref3.preserveDynamicRoutes;if(!route.state&&isInvalidParams(route.params)){route.state=createFakeState(route.params);}var pattern=null;var focusedParams;var collectedParams={};while(route.name in configs){var _route$state$index;var configItem=configs[route.name];var inputPattern=configItem.pattern;if(inputPattern==null){throw new Error('Unexpected: No pattern found for route '+route.name);}pattern=inputPattern;if(route.params){var params=processParamsWithUserSettings(configItem,route.params);if(pattern!==undefined&&pattern!==null){Object.assign(collectedParams,params);}if(deepEqual(focusedRoute,route)){if(preserveDynamicRoutes){focusedParams=params;}else{focusedParams=getParamsWithConventionsCollapsed({params:params,pattern:pattern,routeName:route.name});}}}if(!route.state&&isInvalidParams(route.params)){route.state=createFakeState(route.params);}if(!configItem.screens||route.state===undefined){var _configItem$screens$c;if(configItem.initialRouteName&&configItem.screens&&configItem.initialRouteName in configItem.screens&&(_configItem$screens$c=configItem.screens[configItem.initialRouteName])!=null&&_configItem$screens$c.pattern){var initialRouteConfig=configItem.screens[configItem.initialRouteName];pattern=initialRouteConfig.pattern;if(focusedParams){if(!preserveDynamicRoutes){focusedParams=getParamsWithConventionsCollapsed({params:focusedParams,pattern:pattern,routeName:route.name});}}}break;}var index=(_route$state$index=route.state.index)!=null?_route$state$index:route.state.routes.length-1;var nextRoute=route.state.routes[index];var nestedScreens=configItem.screens;if(nestedScreens&&nextRoute.name in nestedScreens){route=nextRoute;configs=nestedScreens;}else{break;}}if(pattern==null){throw new Error(`No pattern found for route \"${route.name}\". Options are: ${Object.keys(configs).join(', ')}.`);}if(pattern&&!focusedParams&&focusedRoute.params){if(preserveDynamicRoutes){focusedParams=focusedRoute.params;}else{focusedParams=getParamsWithConventionsCollapsed({params:focusedRoute.params,pattern:pattern,routeName:route.name});}Object.assign(focusedParams,collectedParams);}return{pattern:pattern,nextRoute:route,focusedParams:focusedParams,params:collectedParams};}function getPathFromResolvedState(state,configs,_ref4){var preserveGroups=_ref4.preserveGroups,preserveDynamicRoutes=_ref4.preserveDynamicRoutes;var path='';var current=state;var allParams={};while(current){var _current$index,_configs$nextRoute$na,_nextRoute$state$rout,_nextRoute$state$rout2,_nextRoute$state$inde,_nextRoute$state;path+='/';var route=current.routes[(_current$index=current.index)!=null?_current$index:0];if(!route.state&&isInvalidParams(route.params)){route.state=createFakeState(route.params);}var _walkConfigItems=walkConfigItems(route,_getActiveRoute(current),_objectSpread({},configs),{preserveDynamicRoutes:preserveDynamicRoutes}),pattern=_walkConfigItems.pattern,params=_walkConfigItems.params,nextRoute=_walkConfigItems.nextRoute,focusedParams=_walkConfigItems.focusedParams;Object.assign(allParams,params);path+=getPathWithConventionsCollapsed({pattern:pattern,routePath:nextRoute.path,params:allParams,initialRouteName:(_configs$nextRoute$na=configs[nextRoute.name])==null?void 0:_configs$nextRoute$na.initialRouteName,preserveGroups:preserveGroups,preserveDynamicRoutes:preserveDynamicRoutes});if(nextRoute.state&&configs[(_nextRoute$state$rout=nextRoute.state.routes)==null?void 0:(_nextRoute$state$rout2=_nextRoute$state$rout[(_nextRoute$state$inde=(_nextRoute$state=nextRoute.state)==null?void 0:_nextRoute$state.index)!=null?_nextRoute$state$inde:0])==null?void 0:_nextRoute$state$rout2.name]){current=nextRoute.state;}else{if(focusedParams){for(var param in focusedParams){if(focusedParams[param]==='undefined'){delete focusedParams[param];}}var query=new URLSearchParams(focusedParams).toString();if(query){path+=`?${query}`;}}break;}}return{path:appendBaseUrl(basicSanitizePath(path)),params:decodeParams(allParams)};}function decodeParams(params){var parsed={};for(var _ref5 of Object.entries(params)){var _ref6=_slicedToArray(_ref5,2);var key=_ref6[0];var value=_ref6[1];try{if(Array.isArray(value)){parsed[key]=value.map(function(v){return decodeURIComponent(v);});}else{parsed[key]=decodeURIComponent(value);}}catch(_unused){parsed[key]=value;}}return parsed;}function getPathWithConventionsCollapsed(_ref7){var pattern=_ref7.pattern,routePath=_ref7.routePath,params=_ref7.params,preserveGroups=_ref7.preserveGroups,preserveDynamicRoutes=_ref7.preserveDynamicRoutes,initialRouteName=_ref7.initialRouteName;var segments=pattern.split('/');return segments.map(function(p,i){var name=getParamName(p);if(p.startsWith('*')){if(preserveDynamicRoutes){if(name==='not-found'){return'+not-found';}return`[...${name}]`;}if(params[name]){if(Array.isArray(params[name])){return params[name].join('/');}return params[name];}if(i===0){return routePath;}return routePath==null?void 0:routePath.split('/').slice(i+1).join('/');}if(p.startsWith(':')){if(preserveDynamicRoutes){return`[${name}]`;}return params[name];}if(!preserveGroups&&(0,matchers_1.matchGroupName)(p)!=null){if(segments.length-1===i){if(initialRouteName){if(segmentMatchesConvention(initialRouteName)){return'';}return encodeURIComponentPreservingBrackets(initialRouteName);}}return'';}return encodeURIComponentPreservingBrackets(p);}).map(function(v){return v!=null?v:'';}).join('/');}function getParamsWithConventionsCollapsed(_ref8){var pattern=_ref8.pattern,routeName=_ref8.routeName,params=_ref8.params;var processedParams=_objectSpread({},params);var segments=pattern.split('/');segments.filter(function(segment){return segment.startsWith(':');}).forEach(function(segment){var name=getParamName(segment);delete processedParams[name];});if(segments.some(function(segment){return segment.startsWith('*');})){var _ref9;var name=(0,matchers_1.testNotFound)(routeName)?'not-found':(_ref9=(0,matchers_1.matchDeepDynamicRouteName)(routeName))!=null?_ref9:routeName;delete processedParams[name];}return processedParams;}function basicSanitizePath(path){var simplifiedPath=path.replace(/\\/+/g,'/');if(simplifiedPath.length<=1){return simplifiedPath;}return simplifiedPath.replace(/\\/$/,'');}function isInvalidParams(params){if(!params){return false;}if('params'in params&&typeof params.params==='object'&&!!params.params){return true;}return'initial'in params&&typeof params.initial==='boolean'&&'screen'in params;}var getParamName=function getParamName(pattern){return pattern.replace(/^[:*]/,'').replace(/\\?$/,'');};var joinPaths=function joinPaths(){var _ref0;for(var _len=arguments.length,paths=new Array(_len),_key=0;_key<_len;_key++){paths[_key]=arguments[_key];}return(_ref0=[]).concat.apply(_ref0,_toConsumableArray(paths.map(function(p){return p.split('/');}))).filter(Boolean).join('/');};var createConfigItem=function createConfigItem(config,parentPattern){if(typeof config==='string'){var _pattern=parentPattern?joinPaths(parentPattern,config):config;return{pattern:_pattern};}if(config.exact&&config.path===undefined){throw new Error(\"A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. `path: ''`.\");}var pattern=config.exact!==true?joinPaths(parentPattern||'',config.path||''):config.path||'';var screens=config.screens?createNormalizedConfigs(config.screens,pattern):undefined;return{pattern:pattern==null?void 0:pattern.split('/').filter(Boolean).join('/'),stringify:config.stringify,screens:screens,initialRouteName:config.initialRouteName};};var createNormalizedConfigs=function createNormalizedConfigs(options,pattern){return Object.fromEntries(Object.entries(options).map(function(_ref1){var _ref10=_slicedToArray(_ref1,2),name=_ref10[0],c=_ref10[1];return[name,createConfigItem(c,pattern)];}));};function appendBaseUrl(path){var baseUrl=arguments.length>1&&arguments[1]!==undefined?arguments[1]:\"\";if(\"production\"!=='development'){if(baseUrl){return`/${baseUrl.replace(/^\\/+/,'').replace(/\\/$/,'')}${path}`;}}return path;}exports.appendBaseUrl=appendBaseUrl;","map":{"version":3,"names":["core_1","require","matchers_1","DEFAULT_SCREENS","getActiveRoute","state","route","index","routes","length","isInvalidParams","params","createFakeState","stale","type","key","routeNames","name","screen","path","segmentMatchesConvention","segment","matchDynamicName","matchGroupName","matchDeepDynamicRouteName","encodeURIComponentPreservingBrackets","str","encodeURIComponent","replace","getPathFromState","_options","getPathDataFromState","exports","default","arguments","undefined","screens","Error","preserveGroups","preserveDynamicRoutes","options","_objectWithoutProperties","_excluded","validatePathConfig","Object","is","getPathFromResolvedState","JSON","parse","stringify","createNormalizedConfigs","processParamsWithUserSettings","configItem","fromEntries","entries","map","_ref","_ref2","_slicedToArray","value","Array","isArray","String","deepEqual","a","b","i","keysA","keys","keysB","walkConfigItems","focusedRoute","configs","_ref3","pattern","focusedParams","collectedParams","_route$state$index","inputPattern","assign","getParamsWithConventionsCollapsed","routeName","_configItem$screens$c","initialRouteName","initialRouteConfig","nextRoute","nestedScreens","join","_ref4","current","allParams","_current$index","_configs$nextRoute$na","_nextRoute$state$rout","_nextRoute$state$rout2","_nextRoute$state$inde","_nextRoute$state","_walkConfigItems","_objectSpread","getPathWithConventionsCollapsed","routePath","param","query","URLSearchParams","toString","appendBaseUrl","basicSanitizePath","decodeParams","parsed","_ref5","_ref6","v","decodeURIComponent","_unused","_ref7","segments","split","p","getParamName","startsWith","slice","_ref8","processedParams","filter","forEach","some","_ref9","testNotFound","simplifiedPath","initial","joinPaths","_ref0","_len","paths","_key","concat","apply","_toConsumableArray","Boolean","createConfigItem","config","parentPattern","exact","_ref1","_ref10","c","baseUrl"],"sources":["/Users/jonathanbruce/Coding/trackr/node_modules/expo-router/src/fork/getPathFromState.ts"],"sourcesContent":["import { PathConfig, PathConfigMap, validatePathConfig } from '@react-navigation/core';\nimport type { NavigationState, PartialState, Route } from '@react-navigation/routers';\n\nimport {\n  matchDeepDynamicRouteName,\n  matchDynamicName,\n  matchGroupName,\n  testNotFound,\n} from '../matchers';\n\ntype Options<ParamList extends object> = {\n  initialRouteName?: string;\n  screens: PathConfigMap<ParamList>;\n};\n\nexport type State = NavigationState | Omit<PartialState<NavigationState>, 'stale'>;\n\ntype StringifyConfig = Record<string, (value: any) => string>;\n\ntype ConfigItem = {\n  pattern?: string;\n  stringify?: StringifyConfig;\n  screens?: Record<string, ConfigItem>;\n  // Used as fallback for groups\n  initialRouteName?: string;\n};\n\ntype CustomRoute = Route<string> & {\n  state?: State;\n};\n\nconst DEFAULT_SCREENS: PathConfigMap<object> = {};\n\nconst getActiveRoute = (state: State): { name: string; params?: object } => {\n  const route =\n    typeof state.index === 'number'\n      ? state.routes[state.index]\n      : state.routes[state.routes.length - 1];\n\n  if (route.state) {\n    return getActiveRoute(route.state);\n  }\n\n  if (route && isInvalidParams(route.params)) {\n    return getActiveRoute(createFakeState(route.params));\n  }\n\n  return route;\n};\n\nfunction createFakeState(params: StateAsParams) {\n  return {\n    stale: false,\n    type: 'UNKNOWN',\n    key: 'UNKNOWN',\n    index: 0,\n    routeNames: [],\n    routes: [\n      {\n        key: 'UNKNOWN',\n        name: params.screen,\n        params: params.params,\n        path: params.path,\n      },\n    ],\n  };\n}\n\nfunction segmentMatchesConvention(segment: string): boolean {\n  return (\n    segment === 'index' ||\n    matchDynamicName(segment) != null ||\n    matchGroupName(segment) != null ||\n    matchDeepDynamicRouteName(segment) != null\n  );\n}\n\nfunction encodeURIComponentPreservingBrackets(str: string) {\n  return encodeURIComponent(str).replace(/%5B/g, '[').replace(/%5D/g, ']');\n}\n\n/**\n * Utility to serialize a navigation state object to a path string.\n *\n * @example\n * ```js\n * getPathFromState(\n *   {\n *     routes: [\n *       {\n *         name: 'Chat',\n *         params: { author: 'Jane', id: 42 },\n *       },\n *     ],\n *   },\n *   {\n *     screens: {\n *       Chat: {\n *         path: 'chat/:author/:id',\n *         stringify: { author: author => author.toLowerCase() }\n *       }\n *     }\n *   }\n * )\n * ```\n *\n * @param state Navigation state to serialize.\n * @param options Extra options to fine-tune how to serialize the path.\n * @returns Path representing the state, e.g. /foo/bar?count=42.\n */\nexport default function getPathFromState<ParamList extends object>(\n  state: State,\n  _options?: Options<ParamList> & {\n    preserveGroups?: boolean;\n    preserveDynamicRoutes?: boolean;\n  }\n): string {\n  return getPathDataFromState(state, _options).path;\n}\n\nexport function getPathDataFromState<ParamList extends object>(\n  state: State,\n  _options: Options<ParamList> & {\n    preserveGroups?: boolean;\n    preserveDynamicRoutes?: boolean;\n  } = { screens: DEFAULT_SCREENS }\n) {\n  if (state == null) {\n    throw Error(\"Got 'undefined' for the navigation state. You must pass a valid state object.\");\n  }\n\n  const { preserveGroups, preserveDynamicRoutes, ...options } = _options;\n\n  validatePathConfig(options);\n\n  // Expo Router disallows usage without a linking config.\n  if (Object.is(options.screens, DEFAULT_SCREENS)) {\n    throw Error(\"You must pass a 'screens' object to 'getPathFromState' to generate a path.\");\n  }\n\n  return getPathFromResolvedState(\n    JSON.parse(JSON.stringify(state)),\n    // Create a normalized configs object which will be easier to use\n    createNormalizedConfigs(options.screens),\n    { preserveGroups, preserveDynamicRoutes }\n  );\n}\n\nfunction processParamsWithUserSettings(configItem: ConfigItem, params: Record<string, any>) {\n  const stringify = configItem?.stringify;\n\n  return Object.fromEntries(\n    Object.entries(params).map(([key, value]) => [\n      key,\n      // TODO: Strip nullish values here.\n      stringify?.[key]\n        ? stringify[key](value)\n        : // Preserve rest params\n        Array.isArray(value)\n        ? value\n        : String(value),\n    ])\n  );\n}\n\nexport function deepEqual(a: any, b: any) {\n  if (a === b) {\n    return true;\n  }\n\n  if (Array.isArray(a) && Array.isArray(b)) {\n    if (a.length !== b.length) {\n      return false;\n    }\n\n    for (let i = 0; i < a.length; i++) {\n      if (!deepEqual(a[i], b[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  if (typeof a === 'object' && typeof b === 'object') {\n    const keysA = Object.keys(a);\n    const keysB = Object.keys(b);\n\n    if (keysA.length !== keysB.length) {\n      return false;\n    }\n\n    for (const key of keysA) {\n      if (!deepEqual(a[key], b[key])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  return false;\n}\n\nfunction walkConfigItems(\n  route: CustomRoute,\n  focusedRoute: {\n    name: string;\n    params?: object;\n  },\n  configs: Record<string, ConfigItem>,\n  {\n    preserveDynamicRoutes,\n  }: {\n    preserveDynamicRoutes?: boolean;\n  }\n) {\n  // NOTE(EvanBacon): Fill in current route using state that was passed as params.\n  if (!route.state && isInvalidParams(route.params)) {\n    route.state = createFakeState(route.params);\n  }\n\n  let pattern: string | null = null;\n  let focusedParams: Record<string, any> | undefined;\n\n  const collectedParams: Record<string, any> = {};\n\n  while (route.name in configs) {\n    const configItem = configs[route.name];\n    const inputPattern = configItem.pattern;\n\n    if (inputPattern == null) {\n      // This should never happen in Expo Router.\n      throw new Error('Unexpected: No pattern found for route ' + route.name);\n    }\n    pattern = inputPattern;\n\n    if (route.params) {\n      const params = processParamsWithUserSettings(configItem, route.params);\n      if (pattern !== undefined && pattern !== null) {\n        Object.assign(collectedParams, params);\n      }\n      if (deepEqual(focusedRoute, route)) {\n        if (preserveDynamicRoutes) {\n          focusedParams = params;\n        } else {\n          // If this is the focused route, keep the params for later use\n          // We save it here since it's been stringified already\n          focusedParams = getParamsWithConventionsCollapsed({\n            params,\n            pattern,\n            routeName: route.name,\n          });\n        }\n      }\n    }\n\n    if (!route.state && isInvalidParams(route.params)) {\n      route.state = createFakeState(route.params);\n    }\n\n    // If there is no `screens` property or no nested state, we return pattern\n    if (!configItem.screens || route.state === undefined) {\n      if (\n        configItem.initialRouteName &&\n        configItem.screens &&\n        configItem.initialRouteName in configItem.screens &&\n        configItem.screens[configItem.initialRouteName]?.pattern\n      ) {\n        const initialRouteConfig = configItem.screens[configItem.initialRouteName];\n\n        // NOTE(EvanBacon): Big hack to support initial route changes in tab bars.\n        pattern = initialRouteConfig.pattern!;\n        if (focusedParams) {\n          if (!preserveDynamicRoutes) {\n            // If this is the focused route, keep the params for later use\n            // We save it here since it's been stringified already\n            focusedParams = getParamsWithConventionsCollapsed({\n              params: focusedParams,\n              pattern,\n              routeName: route.name,\n            });\n          }\n        }\n      }\n      break;\n    }\n\n    const index = route.state.index ?? route.state.routes.length - 1;\n\n    const nextRoute = route.state.routes[index];\n    const nestedScreens = configItem.screens;\n\n    // if there is config for next route name, we go deeper\n    if (nestedScreens && nextRoute.name in nestedScreens) {\n      route = nextRoute as CustomRoute;\n      configs = nestedScreens;\n    } else {\n      // If not, there is no sense in going deeper in config\n      break;\n    }\n  }\n\n  if (pattern == null) {\n    throw new Error(\n      `No pattern found for route \"${route.name}\". Options are: ${Object.keys(configs).join(', ')}.`\n    );\n  }\n\n  if (pattern && !focusedParams && focusedRoute.params) {\n    if (preserveDynamicRoutes) {\n      focusedParams = focusedRoute.params;\n    } else {\n      // If this is the focused route, keep the params for later use\n      // We save it here since it's been stringified already\n      focusedParams = getParamsWithConventionsCollapsed({\n        params: focusedRoute.params,\n        pattern,\n        routeName: route.name,\n      });\n    }\n    Object.assign(focusedParams, collectedParams);\n  }\n\n  return {\n    pattern,\n    nextRoute: route,\n    focusedParams,\n    params: collectedParams,\n  };\n}\n\nfunction getPathFromResolvedState(\n  state: State,\n  configs: Record<string, ConfigItem>,\n  {\n    preserveGroups,\n    preserveDynamicRoutes,\n  }: { preserveGroups?: boolean; preserveDynamicRoutes?: boolean }\n) {\n  let path = '';\n  let current: State = state;\n\n  const allParams: Record<string, any> = {};\n\n  while (current) {\n    path += '/';\n\n    // Make mutable copies to ensure we don't leak state outside of the function.\n    const route = current.routes[current.index ?? 0] as CustomRoute;\n\n    // NOTE(EvanBacon): Fill in current route using state that was passed as params.\n    // if (isInvalidParams(route.params)) {\n    if (!route.state && isInvalidParams(route.params)) {\n      route.state = createFakeState(route.params);\n    }\n\n    const { pattern, params, nextRoute, focusedParams } = walkConfigItems(\n      route,\n      getActiveRoute(current),\n      { ...configs },\n      { preserveDynamicRoutes }\n    );\n\n    Object.assign(allParams, params);\n\n    path += getPathWithConventionsCollapsed({\n      pattern,\n      routePath: nextRoute.path,\n      params: allParams,\n      initialRouteName: configs[nextRoute.name]?.initialRouteName,\n      preserveGroups,\n      preserveDynamicRoutes,\n    });\n\n    if (\n      nextRoute.state &&\n      // NOTE(EvanBacon): The upstream implementation allows for sending in synthetic states (states that weren't generated by `getStateFromPath`)\n      // and any invalid routes will simply be ignored.\n      // Because of this, we need to check if the next route is valid before continuing, otherwise our more strict\n      // implementation will throw an error.\n      configs[nextRoute.state.routes?.[nextRoute.state?.index ?? 0]?.name]\n    ) {\n      // Continue looping with the next state if available.\n      current = nextRoute.state;\n    } else {\n      // Finished crawling state.\n\n      // Check for query params before exiting.\n      if (focusedParams) {\n        for (const param in focusedParams) {\n          // TODO: This is not good. We shouldn't squat strings named \"undefined\".\n          if (focusedParams[param] === 'undefined') {\n            // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n            delete focusedParams[param];\n          }\n        }\n\n        const query = new URLSearchParams(focusedParams).toString();\n        if (query) {\n          path += `?${query}`;\n        }\n      }\n      break;\n    }\n  }\n\n  return { path: appendBaseUrl(basicSanitizePath(path)), params: decodeParams(allParams) };\n}\n\nfunction decodeParams(params: Record<string, string>) {\n  const parsed: Record<string, any> = {};\n\n  for (const [key, value] of Object.entries(params)) {\n    try {\n      if (Array.isArray(value)) {\n        parsed[key] = value.map((v) => decodeURIComponent(v));\n      } else {\n        parsed[key] = decodeURIComponent(value);\n      }\n    } catch {\n      parsed[key] = value;\n    }\n  }\n\n  return parsed;\n}\n\nfunction getPathWithConventionsCollapsed({\n  pattern,\n  routePath,\n  params,\n  preserveGroups,\n  preserveDynamicRoutes,\n  initialRouteName,\n}: {\n  pattern: string;\n  routePath?: string;\n  params: Record<string, any>;\n  preserveGroups?: boolean;\n  preserveDynamicRoutes?: boolean;\n  initialRouteName?: string;\n}) {\n  const segments = pattern.split('/');\n  return segments\n    .map((p, i) => {\n      const name = getParamName(p);\n\n      // We don't know what to show for wildcard patterns\n      // Showing the route name seems ok, though whatever we show here will be incorrect\n      // Since the page doesn't actually exist\n      if (p.startsWith('*')) {\n        if (preserveDynamicRoutes) {\n          if (name === 'not-found') {\n            return '+not-found';\n          }\n          return `[...${name}]`;\n        }\n        if (params[name]) {\n          if (Array.isArray(params[name])) {\n            return params[name].join('/');\n          }\n          return params[name];\n        }\n        if (i === 0) {\n          // This can occur when a wildcard matches all routes and the given path was `/`.\n          return routePath;\n        }\n        // remove existing segments from route.path and return it\n        // this is used for nested wildcard routes. Without this, the path would add\n        // all nested segments to the beginning of the wildcard route.\n        return routePath\n          ?.split('/')\n          .slice(i + 1)\n          .join('/');\n      }\n\n      // If the path has a pattern for a param, put the param in the path\n      if (p.startsWith(':')) {\n        if (preserveDynamicRoutes) {\n          return `[${name}]`;\n        }\n        // Optional params without value assigned in route.params should be ignored\n        return params[name];\n      }\n\n      if (!preserveGroups && matchGroupName(p) != null) {\n        // When the last part is a group it could be a shared URL\n        // if the route has an initialRouteName defined, then we should\n        // use that as the component path as we can assume it will be shown.\n        if (segments.length - 1 === i) {\n          if (initialRouteName) {\n            // Return an empty string if the init route is ambiguous.\n            if (segmentMatchesConvention(initialRouteName)) {\n              return '';\n            }\n            return encodeURIComponentPreservingBrackets(initialRouteName);\n          }\n        }\n        return '';\n      }\n      // Preserve dynamic syntax for rehydration\n      return encodeURIComponentPreservingBrackets(p);\n    })\n    .map((v) => v ?? '')\n    .join('/');\n}\n\n/** Given a set of query params and a pattern with possible conventions, collapse the conventions and return the remaining params. */\nfunction getParamsWithConventionsCollapsed({\n  pattern,\n  routeName,\n  params,\n}: {\n  pattern: string;\n  /** Route name is required for matching the wildcard route. This is specific to Expo Router. */\n  routeName: string;\n  params: object;\n}): Record<string, string> {\n  const processedParams: Record<string, string> = { ...params };\n\n  // Remove the params present in the pattern since we'll only use the rest for query string\n\n  const segments = pattern.split('/');\n\n  // Dynamic Routes\n  segments\n    .filter((segment) => segment.startsWith(':'))\n    .forEach((segment) => {\n      const name = getParamName(segment);\n      delete processedParams[name];\n    });\n\n  // Deep Dynamic Routes\n  if (segments.some((segment) => segment.startsWith('*'))) {\n    // NOTE(EvanBacon): Drop the param name matching the wildcard route name -- this is specific to Expo Router.\n    const name = testNotFound(routeName)\n      ? 'not-found'\n      : matchDeepDynamicRouteName(routeName) ?? routeName;\n    delete processedParams[name];\n  }\n\n  return processedParams;\n}\n\n// Remove multiple as well as trailing slashes\nfunction basicSanitizePath(path: string) {\n  // Remove duplicate slashes like `foo//bar` -> `foo/bar`\n  const simplifiedPath = path.replace(/\\/+/g, '/');\n  if (simplifiedPath.length <= 1) {\n    return simplifiedPath;\n  }\n  // Remove trailing slash like `foo/bar/` -> `foo/bar`\n  return simplifiedPath.replace(/\\/$/, '');\n}\n\ntype StateAsParams = {\n  initial: boolean;\n  path?: string;\n  screen: string;\n  params: Record<string, any>;\n};\n\n// TODO: Make StackRouter not do this...\n// Detect if the params came from StackRouter using `params` to pass around internal state.\nfunction isInvalidParams(params?: Record<string, any>): params is StateAsParams {\n  if (!params) {\n    return false;\n  }\n\n  if ('params' in params && typeof params.params === 'object' && !!params.params) {\n    return true;\n  }\n\n  return (\n    'initial' in params &&\n    typeof params.initial === 'boolean' &&\n    // \"path\" in params &&\n    'screen' in params\n  );\n}\n\nconst getParamName = (pattern: string) => pattern.replace(/^[:*]/, '').replace(/\\?$/, '');\n\nconst joinPaths = (...paths: string[]): string =>\n  ([] as string[])\n    .concat(...paths.map((p) => p.split('/')))\n    .filter(Boolean)\n    .join('/');\n\nconst createConfigItem = (\n  config: PathConfig<object> | string,\n  parentPattern?: string\n): ConfigItem => {\n  if (typeof config === 'string') {\n    // If a string is specified as the value of the key(e.g. Foo: '/path'), use it as the pattern\n    const pattern = parentPattern ? joinPaths(parentPattern, config) : config;\n\n    return { pattern };\n  }\n\n  if (config.exact && config.path === undefined) {\n    throw new Error(\n      \"A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. `path: ''`.\"\n    );\n  }\n\n  // If an object is specified as the value (e.g. Foo: { ... }),\n  // It can have `path` property and `screens` prop which has nested configs\n  const pattern =\n    config.exact !== true ? joinPaths(parentPattern || '', config.path || '') : config.path || '';\n\n  const screens = config.screens ? createNormalizedConfigs(config.screens, pattern) : undefined;\n\n  return {\n    // Normalize pattern to remove any leading, trailing slashes, duplicate slashes etc.\n    pattern: pattern?.split('/').filter(Boolean).join('/'),\n    stringify: config.stringify,\n    screens,\n    initialRouteName: config.initialRouteName,\n  };\n};\n\nconst createNormalizedConfigs = (\n  options: PathConfigMap<object>,\n  pattern?: string\n): Record<string, ConfigItem> =>\n  Object.fromEntries(\n    Object.entries(options).map(([name, c]) => [name, createConfigItem(c, pattern)])\n  );\n\nexport function appendBaseUrl(\n  path: string,\n  baseUrl: string | undefined = process.env.EXPO_BASE_URL\n) {\n  if (process.env.NODE_ENV !== 'development') {\n    if (baseUrl) {\n      return `/${baseUrl.replace(/^\\/+/, '').replace(/\\/$/, '')}${path}`;\n    }\n  }\n  return path;\n}\n"],"mappings":"imCAAA,IAAAA,MAAA,CAAAC,OAAA,2BAGA,IAAAC,UAAA,CAAAD,OAAA,gBA4BA,GAAM,CAAAE,eAAe,CAA0B,EAAE,CAEjD,GAAM,CAAAC,eAAc,CAAG,QAAjB,CAAAA,cAAcA,CAAIC,KAAY,CAAuC,CACzE,GAAM,CAAAC,KAAK,CACT,MAAO,CAAAD,KAAK,CAACE,KAAK,GAAK,QAAQ,CAC3BF,KAAK,CAACG,MAAM,CAACH,KAAK,CAACE,KAAK,CAAC,CACzBF,KAAK,CAACG,MAAM,CAACH,KAAK,CAACG,MAAM,CAACC,MAAM,CAAG,CAAC,CAAC,CAE3C,GAAIH,KAAK,CAACD,KAAK,CAAE,CACf,MAAO,CAAAD,eAAc,CAACE,KAAK,CAACD,KAAK,CAAC,C,CAGpC,GAAIC,KAAK,EAAII,eAAe,CAACJ,KAAK,CAACK,MAAM,CAAC,CAAE,CAC1C,MAAO,CAAAP,eAAc,CAACQ,eAAe,CAACN,KAAK,CAACK,MAAM,CAAC,CAAC,C,CAGtD,MAAO,CAAAL,KAAK,CACd,CAAC,CAED,QAAS,CAAAM,eAAeA,CAACD,MAAqB,EAC5C,MAAO,CACLE,KAAK,CAAE,KAAK,CACZC,IAAI,CAAE,SAAS,CACfC,GAAG,CAAE,SAAS,CACdR,KAAK,CAAE,CAAC,CACRS,UAAU,CAAE,EAAE,CACdR,MAAM,CAAE,CACN,CACEO,GAAG,CAAE,SAAS,CACdE,IAAI,CAAEN,MAAM,CAACO,MAAM,CACnBP,MAAM,CAAEA,MAAM,CAACA,MAAM,CACrBQ,IAAI,CAAER,MAAM,CAACQ,I,CACd,C,CAEJ,CACH,CAEA,QAAS,CAAAC,wBAAwBA,CAACC,OAAe,EAC/C,MACE,CAAAA,OAAO,GAAK,OAAO,EACnB,GAAAnB,UAAA,CAAAoB,gBAAgB,EAACD,OAAO,CAAC,EAAI,IAAI,EACjC,GAAAnB,UAAA,CAAAqB,cAAc,EAACF,OAAO,CAAC,EAAI,IAAI,EAC/B,GAAAnB,UAAA,CAAAsB,yBAAyB,EAACH,OAAO,CAAC,EAAI,IAAI,CAE9C,CAEA,QAAS,CAAAI,oCAAoCA,CAACC,GAAW,EACvD,MAAO,CAAAC,kBAAkB,CAACD,GAAG,CAAC,CAACE,OAAO,CAAC,MAAM,CAAE,GAAG,CAAC,CAACA,OAAO,CAAC,MAAM,CAAE,GAAG,CAAC,CAC1E,CA+BA,QAAwB,CAAAC,gBAAgBA,CACtCxB,KAAY,CACZyB,QAGC,EAED,MAAO,CAAAC,oBAAoB,CAAC1B,KAAK,CAAEyB,QAAQ,CAAC,CAACX,IAAI,CACnD,CARAa,OAAA,CAAAC,OAAA,CAAAJ,gBAAA,CAUA,QAAgB,CAAAE,oBAAoBA,CAClC1B,KAAY,CAIoB,IAHhC,CAAAyB,QAAA,CAAAI,SAAA,CAAAzB,MAAA,IAAAyB,SAAA,MAAAC,SAAA,CAAAD,SAAA,IAGI,CAAEE,OAAO,CAAEjC,eAAe,CAAE,CAEhC,GAAIE,KAAK,EAAI,IAAI,CAAE,CACjB,KAAM,CAAAgC,KAAK,CAAC,+EAA+E,CAAC,C,CAG9F,GAAQ,CAAAC,cAAc,CAAwCR,QAAQ,CAA9DQ,cAAc,CAAEC,qBAAqB,CAAiBT,QAAQ,CAA9CS,qBAAqB,CAAKC,OAAO,CAAAC,wBAAA,CAAKX,QAAQ,CAAAY,SAAA,EAEtE,GAAA1C,MAAA,CAAA2C,kBAAkB,EAACH,OAAO,CAAC,CAG3B,GAAII,MAAM,CAACC,EAAE,CAACL,OAAO,CAACJ,OAAO,CAAEjC,eAAe,CAAC,CAAE,CAC/C,KAAM,CAAAkC,KAAK,CAAC,4EAA4E,CAAC,C,CAG3F,MAAO,CAAAS,wBAAwB,CAC7BC,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,SAAS,CAAC5C,KAAK,CAAC,CAAC,CAEjC6C,uBAAuB,CAACV,OAAO,CAACJ,OAAO,CAAC,CACxC,CAAEE,cAAc,CAAdA,cAAc,CAAEC,qBAAqB,CAArBA,qBAAqB,CAAE,CAC1C,CACH,CA1BAP,OAAA,CAAAD,oBAAA,CAAAA,oBAAA,CA4BA,QAAS,CAAAoB,6BAA6BA,CAACC,UAAsB,CAAEzC,MAA2B,EACxF,GAAM,CAAAsC,SAAS,CAAGG,UAAU,cAAVA,UAAU,CAAEH,SAAS,CAEvC,MAAO,CAAAL,MAAM,CAACS,WAAW,CACvBT,MAAM,CAACU,OAAO,CAAC3C,MAAM,CAAC,CAAC4C,GAAG,CAAC,SAAAC,IAAA,MAAAC,KAAA,CAAAC,cAAA,CAAAF,IAAA,IAAEzC,GAAG,CAAA0C,KAAA,IAAEE,KAAK,CAAAF,KAAA,UAAM,CAC3C1C,GAAG,CAEHkC,SAAS,QAATA,SAAS,CAAGlC,GAAG,CAAC,CACZkC,SAAS,CAAClC,GAAG,CAAC,CAAC4C,KAAK,CAAC,CAEvBC,KAAK,CAACC,OAAO,CAACF,KAAK,CAAC,CAClBA,KAAK,CACLG,MAAM,CAACH,KAAK,CAAC,CAClB,GAAC,CACH,CACH,CAEA,QAAgB,CAAAI,SAASA,CAACC,CAAM,CAAEC,CAAM,EACtC,GAAID,CAAC,GAAKC,CAAC,CAAE,CACX,MAAO,KAAI,C,CAGb,GAAIL,KAAK,CAACC,OAAO,CAACG,CAAC,CAAC,EAAIJ,KAAK,CAACC,OAAO,CAACI,CAAC,CAAC,CAAE,CACxC,GAAID,CAAC,CAACvD,MAAM,GAAKwD,CAAC,CAACxD,MAAM,CAAE,CACzB,MAAO,MAAK,C,CAGd,IAAK,GAAI,CAAAyD,CAAC,CAAG,CAAC,CAAEA,CAAC,CAAGF,CAAC,CAACvD,MAAM,CAAEyD,CAAC,EAAE,CAAE,CACjC,GAAI,CAACH,SAAS,CAACC,CAAC,CAACE,CAAC,CAAC,CAAED,CAAC,CAACC,CAAC,CAAC,CAAC,CAAE,CAC1B,MAAO,MAAK,C,EAIhB,MAAO,KAAI,C,CAGb,GAAI,MAAO,CAAAF,CAAC,GAAK,QAAQ,EAAI,MAAO,CAAAC,CAAC,GAAK,QAAQ,CAAE,CAClD,GAAM,CAAAE,KAAK,CAAGvB,MAAM,CAACwB,IAAI,CAACJ,CAAC,CAAC,CAC5B,GAAM,CAAAK,KAAK,CAAGzB,MAAM,CAACwB,IAAI,CAACH,CAAC,CAAC,CAE5B,GAAIE,KAAK,CAAC1D,MAAM,GAAK4D,KAAK,CAAC5D,MAAM,CAAE,CACjC,MAAO,MAAK,C,CAGd,IAAK,GAAM,CAAAM,GAAG,GAAI,CAAAoD,KAAK,CAAE,CACvB,GAAI,CAACJ,SAAS,CAACC,CAAC,CAACjD,GAAG,CAAC,CAAEkD,CAAC,CAAClD,GAAG,CAAC,CAAC,CAAE,CAC9B,MAAO,MAAK,C,EAIhB,MAAO,KAAI,C,CAGb,MAAO,MAAK,CACd,CArCAiB,OAAA,CAAA+B,SAAA,CAAAA,SAAA,CAuCA,QAAS,CAAAO,eAAeA,CACtBhE,KAAkB,CAClBiE,YAGC,CACDC,OAAmC,CAAAC,KAAA,CAKlC,IAHC,CAAAlC,qBAAqB,CAAAkC,KAAA,CAArBlC,qBAAqB,CAMvB,GAAI,CAACjC,KAAK,CAACD,KAAK,EAAIK,eAAe,CAACJ,KAAK,CAACK,MAAM,CAAC,CAAE,CACjDL,KAAK,CAACD,KAAK,CAAGO,eAAe,CAACN,KAAK,CAACK,MAAM,CAAC,C,CAG7C,GAAI,CAAA+D,OAAO,CAAkB,IAAI,CACjC,GAAI,CAAAC,aAA8C,CAElD,GAAM,CAAAC,eAAe,CAAwB,EAAE,CAE/C,MAAOtE,KAAK,CAACW,IAAI,GAAI,CAAAuD,OAAO,CAAE,KAAAK,kBAAA,CAC5B,GAAM,CAAAzB,UAAU,CAAGoB,OAAO,CAAClE,KAAK,CAACW,IAAI,CAAC,CACtC,GAAM,CAAA6D,YAAY,CAAG1B,UAAU,CAACsB,OAAO,CAEvC,GAAII,YAAY,EAAI,IAAI,CAAE,CAExB,KAAM,IAAI,CAAAzC,KAAK,CAAC,yCAAyC,CAAG/B,KAAK,CAACW,IAAI,CAAC,C,CAEzEyD,OAAO,CAAGI,YAAY,CAEtB,GAAIxE,KAAK,CAACK,MAAM,CAAE,CAChB,GAAM,CAAAA,MAAM,CAAGwC,6BAA6B,CAACC,UAAU,CAAE9C,KAAK,CAACK,MAAM,CAAC,CACtE,GAAI+D,OAAO,GAAKvC,SAAS,EAAIuC,OAAO,GAAK,IAAI,CAAE,CAC7C9B,MAAM,CAACmC,MAAM,CAACH,eAAe,CAAEjE,MAAM,CAAC,C,CAExC,GAAIoD,SAAS,CAACQ,YAAY,CAAEjE,KAAK,CAAC,CAAE,CAClC,GAAIiC,qBAAqB,CAAE,CACzBoC,aAAa,CAAGhE,MAAM,C,CACvB,IAAM,CAGLgE,aAAa,CAAGK,iCAAiC,CAAC,CAChDrE,MAAM,CAANA,MAAM,CACN+D,OAAO,CAAPA,OAAO,CACPO,SAAS,CAAE3E,KAAK,CAACW,I,CAClB,CAAC,C,GAKR,GAAI,CAACX,KAAK,CAACD,KAAK,EAAIK,eAAe,CAACJ,KAAK,CAACK,MAAM,CAAC,CAAE,CACjDL,KAAK,CAACD,KAAK,CAAGO,eAAe,CAACN,KAAK,CAACK,MAAM,CAAC,C,CAI7C,GAAI,CAACyC,UAAU,CAAChB,OAAO,EAAI9B,KAAK,CAACD,KAAK,GAAK8B,SAAS,CAAE,KAAA+C,qBAAA,CACpD,GACE9B,UAAU,CAAC+B,gBAAgB,EAC3B/B,UAAU,CAAChB,OAAO,EAClBgB,UAAU,CAAC+B,gBAAgB,GAAI,CAAA/B,UAAU,CAAChB,OAAO,GAAA8C,qBAAA,CACjD9B,UAAU,CAAChB,OAAO,CAACgB,UAAU,CAAC+B,gBAAgB,CAAC,SAA/CD,qBAAA,CAAiDR,OAAO,CACxD,CACA,GAAM,CAAAU,kBAAkB,CAAGhC,UAAU,CAAChB,OAAO,CAACgB,UAAU,CAAC+B,gBAAgB,CAAC,CAG1ET,OAAO,CAAGU,kBAAkB,CAACV,OAAQ,CACrC,GAAIC,aAAa,CAAE,CACjB,GAAI,CAACpC,qBAAqB,CAAE,CAG1BoC,aAAa,CAAGK,iCAAiC,CAAC,CAChDrE,MAAM,CAAEgE,aAAa,CACrBD,OAAO,CAAPA,OAAO,CACPO,SAAS,CAAE3E,KAAK,CAACW,I,CAClB,CAAC,C,GAIR,M,CAGF,GAAM,CAAAV,KAAK,EAAAsE,kBAAA,CAAGvE,KAAK,CAACD,KAAK,CAACE,KAAK,QAAAsE,kBAAA,CAAIvE,KAAK,CAACD,KAAK,CAACG,MAAM,CAACC,MAAM,CAAG,CAAC,CAEhE,GAAM,CAAA4E,SAAS,CAAG/E,KAAK,CAACD,KAAK,CAACG,MAAM,CAACD,KAAK,CAAC,CAC3C,GAAM,CAAA+E,aAAa,CAAGlC,UAAU,CAAChB,OAAO,CAGxC,GAAIkD,aAAa,EAAID,SAAS,CAACpE,IAAI,GAAI,CAAAqE,aAAa,CAAE,CACpDhF,KAAK,CAAG+E,SAAwB,CAChCb,OAAO,CAAGc,aAAa,C,CACxB,IAAM,CAEL,M,EAIJ,GAAIZ,OAAO,EAAI,IAAI,CAAE,CACnB,KAAM,IAAI,CAAArC,KAAK,CACb,+BAA+B/B,KAAK,CAACW,IAAI,mBAAmB2B,MAAM,CAACwB,IAAI,CAACI,OAAO,CAAC,CAACe,IAAI,CAAC,IAAI,CAAC,GAAG,CAC/F,C,CAGH,GAAIb,OAAO,EAAI,CAACC,aAAa,EAAIJ,YAAY,CAAC5D,MAAM,CAAE,CACpD,GAAI4B,qBAAqB,CAAE,CACzBoC,aAAa,CAAGJ,YAAY,CAAC5D,MAAM,C,CACpC,IAAM,CAGLgE,aAAa,CAAGK,iCAAiC,CAAC,CAChDrE,MAAM,CAAE4D,YAAY,CAAC5D,MAAM,CAC3B+D,OAAO,CAAPA,OAAO,CACPO,SAAS,CAAE3E,KAAK,CAACW,I,CAClB,CAAC,C,CAEJ2B,MAAM,CAACmC,MAAM,CAACJ,aAAa,CAAEC,eAAe,CAAC,C,CAG/C,MAAO,CACLF,OAAO,CAAPA,OAAO,CACPW,SAAS,CAAE/E,KAAK,CAChBqE,aAAa,CAAbA,aAAa,CACbhE,MAAM,CAAEiE,e,CACT,CACH,CAEA,QAAS,CAAA9B,wBAAwBA,CAC/BzC,KAAY,CACZmE,OAAmC,CAAAgB,KAAA,CAI6B,IAF9D,CAAAlD,cAAc,CAAAkD,KAAA,CAAdlD,cAAc,CACdC,qBAAqB,CAAAiD,KAAA,CAArBjD,qBAAqB,CAGvB,GAAI,CAAApB,IAAI,CAAG,EAAE,CACb,GAAI,CAAAsE,OAAO,CAAUpF,KAAK,CAE1B,GAAM,CAAAqF,SAAS,CAAwB,EAAE,CAEzC,MAAOD,OAAO,CAAE,KAAAE,cAAA,CAAAC,qBAAA,CAAAC,qBAAA,CAAAC,sBAAA,CAAAC,qBAAA,CAAAC,gBAAA,CACd7E,IAAI,EAAI,GAAG,CAGX,GAAM,CAAAb,KAAK,CAAGmF,OAAO,CAACjF,MAAM,EAAAmF,cAAA,CAACF,OAAO,CAAClF,KAAK,QAAAoF,cAAA,CAAI,CAAC,CAAgB,CAI/D,GAAI,CAACrF,KAAK,CAACD,KAAK,EAAIK,eAAe,CAACJ,KAAK,CAACK,MAAM,CAAC,CAAE,CACjDL,KAAK,CAACD,KAAK,CAAGO,eAAe,CAACN,KAAK,CAACK,MAAM,CAAC,C,CAG7C,IAAAsF,gBAAA,CAAsD3B,eAAe,CACnEhE,KAAK,CACLF,eAAc,CAACqF,OAAO,CAAC,CAAAS,aAAA,IAClB1B,OAAO,EACZ,CAAEjC,qBAAqB,CAArBA,qBAAqB,CAAE,CAC1B,CALOmC,OAAO,CAAAuB,gBAAA,CAAPvB,OAAO,CAAE/D,MAAM,CAAAsF,gBAAA,CAANtF,MAAM,CAAE0E,SAAS,CAAAY,gBAAA,CAATZ,SAAS,CAAEV,aAAa,CAAAsB,gBAAA,CAAbtB,aAAa,CAOjD/B,MAAM,CAACmC,MAAM,CAACW,SAAS,CAAE/E,MAAM,CAAC,CAEhCQ,IAAI,EAAIgF,+BAA+B,CAAC,CACtCzB,OAAO,CAAPA,OAAO,CACP0B,SAAS,CAAEf,SAAS,CAAClE,IAAI,CACzBR,MAAM,CAAE+E,SAAS,CACjBP,gBAAgB,EAAAS,qBAAA,CAAEpB,OAAO,CAACa,SAAS,CAACpE,IAAI,CAAC,eAAvB2E,qBAAA,CAAyBT,gBAAgB,CAC3D7C,cAAc,CAAdA,cAAc,CACdC,qBAAqB,CAArBA,qB,CACD,CAAC,CAEF,GACE8C,SAAS,CAAChF,KAAK,EAKfmE,OAAO,EAAAqB,qBAAA,CAACR,SAAS,CAAChF,KAAK,CAACG,MAAM,gBAAAsF,sBAAA,CAAtBD,qBAAA,EAAAE,qBAAA,EAAAC,gBAAA,CAAyBX,SAAS,CAAChF,KAAK,eAAf2F,gBAAA,CAAiBzF,KAAK,QAAAwF,qBAAA,CAAI,CAAC,CAAC,eAArDD,sBAAA,CAAuD7E,IAAI,CAAC,CACpE,CAEAwE,OAAO,CAAGJ,SAAS,CAAChF,KAAK,C,CAC1B,IAAM,CAIL,GAAIsE,aAAa,CAAE,CACjB,IAAK,GAAM,CAAA0B,KAAK,GAAI,CAAA1B,aAAa,CAAE,CAEjC,GAAIA,aAAa,CAAC0B,KAAK,CAAC,GAAK,WAAW,CAAE,CAExC,MAAO,CAAA1B,aAAa,CAAC0B,KAAK,CAAC,C,EAI/B,GAAM,CAAAC,KAAK,CAAG,GAAI,CAAAC,eAAe,CAAC5B,aAAa,CAAC,CAAC6B,QAAQ,EAAE,CAC3D,GAAIF,KAAK,CAAE,CACTnF,IAAI,EAAI,IAAImF,KAAK,EAAE,C,EAGvB,M,EAIJ,MAAO,CAAEnF,IAAI,CAAEsF,aAAa,CAACC,iBAAiB,CAACvF,IAAI,CAAC,CAAC,CAAER,MAAM,CAAEgG,YAAY,CAACjB,SAAS,CAAC,CAAE,CAC1F,CAEA,QAAS,CAAAiB,YAAYA,CAAChG,MAA8B,EAClD,GAAM,CAAAiG,MAAM,CAAwB,EAAE,CAEtC,QAAAC,KAAA,GAA2B,CAAAjE,MAAM,CAACU,OAAO,CAAC3C,MAAM,CAAC,CAAE,KAAAmG,KAAA,CAAApD,cAAA,CAAAmD,KAAA,OAAvC,CAAA9F,GAAG,CAAA+F,KAAA,OAAE,CAAAnD,KAAK,CAAAmD,KAAA,IACpB,GAAI,CACF,GAAIlD,KAAK,CAACC,OAAO,CAACF,KAAK,CAAC,CAAE,CACxBiD,MAAM,CAAC7F,GAAG,CAAC,CAAG4C,KAAK,CAACJ,GAAG,CAAC,SAACwD,CAAC,QAAK,CAAAC,kBAAkB,CAACD,CAAC,CAAC,GAAC,C,CACtD,IAAM,CACLH,MAAM,CAAC7F,GAAG,CAAC,CAAGiG,kBAAkB,CAACrD,KAAK,CAAC,C,EAEzC,MAAAsD,OAAA,CAAM,CACNL,MAAM,CAAC7F,GAAG,CAAC,CAAG4C,KAAK,C,EAIvB,MAAO,CAAAiD,MAAM,CACf,CAEA,QAAS,CAAAT,+BAA+BA,CAAAe,KAAA,CAcvC,IAbC,CAAAxC,OAAO,CAAAwC,KAAA,CAAPxC,OAAO,CACP0B,SAAS,CAAAc,KAAA,CAATd,SAAS,CACTzF,MAAM,CAAAuG,KAAA,CAANvG,MAAM,CACN2B,cAAc,CAAA4E,KAAA,CAAd5E,cAAc,CACdC,qBAAqB,CAAA2E,KAAA,CAArB3E,qBAAqB,CACrB4C,gBAAgB,CAAA+B,KAAA,CAAhB/B,gBAAgB,CAShB,GAAM,CAAAgC,QAAQ,CAAGzC,OAAO,CAAC0C,KAAK,CAAC,GAAG,CAAC,CACnC,MAAO,CAAAD,QAAQ,CACZ5D,GAAG,CAAC,SAAC8D,CAAC,CAAEnD,CAAC,CAAI,CACZ,GAAM,CAAAjD,IAAI,CAAGqG,YAAY,CAACD,CAAC,CAAC,CAK5B,GAAIA,CAAC,CAACE,UAAU,CAAC,GAAG,CAAC,CAAE,CACrB,GAAIhF,qBAAqB,CAAE,CACzB,GAAItB,IAAI,GAAK,WAAW,CAAE,CACxB,MAAO,YAAY,C,CAErB,MAAO,OAAOA,IAAI,GAAG,C,CAEvB,GAAIN,MAAM,CAACM,IAAI,CAAC,CAAE,CAChB,GAAI2C,KAAK,CAACC,OAAO,CAAClD,MAAM,CAACM,IAAI,CAAC,CAAC,CAAE,CAC/B,MAAO,CAAAN,MAAM,CAACM,IAAI,CAAC,CAACsE,IAAI,CAAC,GAAG,CAAC,C,CAE/B,MAAO,CAAA5E,MAAM,CAACM,IAAI,CAAC,C,CAErB,GAAIiD,CAAC,GAAK,CAAC,CAAE,CAEX,MAAO,CAAAkC,SAAS,C,CAKlB,MAAO,CAAAA,SAAS,cAATA,SAAS,CACZgB,KAAK,CAAC,GAAG,CAAC,CACXI,KAAK,CAACtD,CAAC,CAAG,CAAC,CAAC,CACZqB,IAAI,CAAC,GAAG,CAAC,C,CAId,GAAI8B,CAAC,CAACE,UAAU,CAAC,GAAG,CAAC,CAAE,CACrB,GAAIhF,qBAAqB,CAAE,CACzB,MAAO,IAAItB,IAAI,GAAG,C,CAGpB,MAAO,CAAAN,MAAM,CAACM,IAAI,CAAC,C,CAGrB,GAAI,CAACqB,cAAc,EAAI,GAAApC,UAAA,CAAAqB,cAAc,EAAC8F,CAAC,CAAC,EAAI,IAAI,CAAE,CAIhD,GAAIF,QAAQ,CAAC1G,MAAM,CAAG,CAAC,GAAKyD,CAAC,CAAE,CAC7B,GAAIiB,gBAAgB,CAAE,CAEpB,GAAI/D,wBAAwB,CAAC+D,gBAAgB,CAAC,CAAE,CAC9C,MAAO,EAAE,C,CAEX,MAAO,CAAA1D,oCAAoC,CAAC0D,gBAAgB,CAAC,C,EAGjE,MAAO,EAAE,C,CAGX,MAAO,CAAA1D,oCAAoC,CAAC4F,CAAC,CAAC,CAChD,CAAC,CAAC,CACD9D,GAAG,CAAC,SAACwD,CAAC,QAAK,CAAAA,CAAC,OAADA,CAAC,CAAI,EAAE,GAAC,CACnBxB,IAAI,CAAC,GAAG,CAAC,CACd,CAGA,QAAS,CAAAP,iCAAiCA,CAAAyC,KAAA,CASzC,IARC,CAAA/C,OAAO,CAAA+C,KAAA,CAAP/C,OAAO,CACPO,SAAS,CAAAwC,KAAA,CAATxC,SAAS,CACTtE,MAAM,CAAA8G,KAAA,CAAN9G,MAAM,CAON,GAAM,CAAA+G,eAAe,CAAAxB,aAAA,IAAgCvF,MAAM,CAAE,CAI7D,GAAM,CAAAwG,QAAQ,CAAGzC,OAAO,CAAC0C,KAAK,CAAC,GAAG,CAAC,CAGnCD,QAAQ,CACLQ,MAAM,CAAC,SAACtG,OAAO,QAAK,CAAAA,OAAO,CAACkG,UAAU,CAAC,GAAG,CAAC,GAAC,CAC5CK,OAAO,CAAC,SAACvG,OAAO,CAAI,CACnB,GAAM,CAAAJ,IAAI,CAAGqG,YAAY,CAACjG,OAAO,CAAC,CAClC,MAAO,CAAAqG,eAAe,CAACzG,IAAI,CAAC,CAC9B,CAAC,CAAC,CAGJ,GAAIkG,QAAQ,CAACU,IAAI,CAAC,SAACxG,OAAO,QAAK,CAAAA,OAAO,CAACkG,UAAU,CAAC,GAAG,CAAC,GAAC,CAAE,KAAAO,KAAA,CAEvD,GAAM,CAAA7G,IAAI,CAAG,GAAAf,UAAA,CAAA6H,YAAY,EAAC9C,SAAS,CAAC,CAChC,WAAW,EAAA6C,KAAA,CACX,GAAA5H,UAAA,CAAAsB,yBAAyB,EAACyD,SAAS,CAAC,QAAA6C,KAAA,CAAI7C,SAAS,CACrD,MAAO,CAAAyC,eAAe,CAACzG,IAAI,CAAC,C,CAG9B,MAAO,CAAAyG,eAAe,CACxB,CAGA,QAAS,CAAAhB,iBAAiBA,CAACvF,IAAY,EAErC,GAAM,CAAA6G,cAAc,CAAG7G,IAAI,CAACS,OAAO,CAAC,MAAM,CAAE,GAAG,CAAC,CAChD,GAAIoG,cAAc,CAACvH,MAAM,EAAI,CAAC,CAAE,CAC9B,MAAO,CAAAuH,cAAc,C,CAGvB,MAAO,CAAAA,cAAc,CAACpG,OAAO,CAAC,KAAK,CAAE,EAAE,CAAC,CAC1C,CAWA,QAAS,CAAAlB,eAAeA,CAACC,MAA4B,EACnD,GAAI,CAACA,MAAM,CAAE,CACX,MAAO,MAAK,C,CAGd,GAAI,QAAQ,EAAI,CAAAA,MAAM,EAAI,MAAO,CAAAA,MAAM,CAACA,MAAM,GAAK,QAAQ,EAAI,CAAC,CAACA,MAAM,CAACA,MAAM,CAAE,CAC9E,MAAO,KAAI,C,CAGb,MACE,SAAS,EAAI,CAAAA,MAAM,EACnB,MAAO,CAAAA,MAAM,CAACsH,OAAO,GAAK,SAAS,EAEnC,QAAQ,EAAI,CAAAtH,MAAM,CAEtB,CAEA,GAAM,CAAA2G,YAAY,CAAG,QAAf,CAAAA,YAAYA,CAAI5C,OAAe,QAAK,CAAAA,OAAO,CAAC9C,OAAO,CAAC,OAAO,CAAE,EAAE,CAAC,CAACA,OAAO,CAAC,KAAK,CAAE,EAAE,CAAC,GAEzF,GAAM,CAAAsG,SAAS,CAAG,QAAZ,CAAAA,SAASA,CAAA,MAAAC,KAAA,SAAAC,IAAA,CAAAlG,SAAA,CAAAzB,MAAA,CAAO4H,KAAe,KAAAzE,KAAA,CAAAwE,IAAA,EAAAE,IAAA,GAAAA,IAAA,CAAAF,IAAA,CAAAE,IAAA,IAAfD,KAAe,CAAAC,IAAA,EAAApG,SAAA,CAAAoG,IAAA,SAClC,CAAAH,KAAA,GAAe,EACbI,MAAM,CAAAC,KAAA,CAAAL,KAAA,CAAAM,kBAAA,CAAIJ,KAAK,CAAC9E,GAAG,CAAC,SAAC8D,CAAC,QAAK,CAAAA,CAAC,CAACD,KAAK,CAAC,GAAG,CAAC,GAAC,EAAC,CACzCO,MAAM,CAACe,OAAO,CAAC,CACfnD,IAAI,CAAC,GAAG,CAAC,GAEd,GAAM,CAAAoD,gBAAgB,CAAG,QAAnB,CAAAA,gBAAgBA,CACpBC,MAAmC,CACnCC,aAAsB,CACR,CACd,GAAI,MAAO,CAAAD,MAAM,GAAK,QAAQ,CAAE,CAE9B,GAAM,CAAAlE,QAAO,CAAGmE,aAAa,CAAGX,SAAS,CAACW,aAAa,CAAED,MAAM,CAAC,CAAGA,MAAM,CAEzE,MAAO,CAAElE,OAAO,CAAPA,QAAO,CAAE,C,CAGpB,GAAIkE,MAAM,CAACE,KAAK,EAAIF,MAAM,CAACzH,IAAI,GAAKgB,SAAS,CAAE,CAC7C,KAAM,IAAI,CAAAE,KAAK,CACb,sJAAsJ,CACvJ,C,CAKH,GAAM,CAAAqC,OAAO,CACXkE,MAAM,CAACE,KAAK,GAAK,IAAI,CAAGZ,SAAS,CAACW,aAAa,EAAI,EAAE,CAAED,MAAM,CAACzH,IAAI,EAAI,EAAE,CAAC,CAAGyH,MAAM,CAACzH,IAAI,EAAI,EAAE,CAE/F,GAAM,CAAAiB,OAAO,CAAGwG,MAAM,CAACxG,OAAO,CAAGc,uBAAuB,CAAC0F,MAAM,CAACxG,OAAO,CAAEsC,OAAO,CAAC,CAAGvC,SAAS,CAE7F,MAAO,CAELuC,OAAO,CAAEA,OAAO,cAAPA,OAAO,CAAE0C,KAAK,CAAC,GAAG,CAAC,CAACO,MAAM,CAACe,OAAO,CAAC,CAACnD,IAAI,CAAC,GAAG,CAAC,CACtDtC,SAAS,CAAE2F,MAAM,CAAC3F,SAAS,CAC3Bb,OAAO,CAAPA,OAAO,CACP+C,gBAAgB,CAAEyD,MAAM,CAACzD,gB,CAC1B,CACH,CAAC,CAED,GAAM,CAAAjC,uBAAuB,CAAG,QAA1B,CAAAA,uBAAuBA,CAC3BV,OAA8B,CAC9BkC,OAAgB,QAEhB,CAAA9B,MAAM,CAACS,WAAW,CAChBT,MAAM,CAACU,OAAO,CAACd,OAAO,CAAC,CAACe,GAAG,CAAC,SAAAwF,KAAA,MAAAC,MAAA,CAAAtF,cAAA,CAAAqF,KAAA,IAAE9H,IAAI,CAAA+H,MAAA,IAAEC,CAAC,CAAAD,MAAA,UAAM,CAAC/H,IAAI,CAAE0H,gBAAgB,CAACM,CAAC,CAAEvE,OAAO,CAAC,CAAC,GAAC,CACjF,GAEH,QAAgB,CAAA+B,aAAaA,CAC3BtF,IAAY,CAC2C,IAAvD,CAAA+H,OAAA,CAAAhH,SAAA,CAAAzB,MAAA,IAAAyB,SAAA,MAAAC,SAAA,CAAAD,SAAA,OAEA,GAAI,eAAyB,aAAa,CAAE,CAC1C,GAAIgH,OAAO,CAAE,CACX,MAAO,IAAIA,OAAO,CAACtH,OAAO,CAAC,MAAM,CAAE,EAAE,CAAC,CAACA,OAAO,CAAC,KAAK,CAAE,EAAE,CAAC,GAAGT,IAAI,EAAE,C,EAGtE,MAAO,CAAAA,IAAI,CACb,CAVAa,OAAA,CAAAyE,aAAA,CAAAA,aAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}